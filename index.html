<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head>
  <title>Solution Methods for Microeconomic Dynamic Stochastic Optimization Problems</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="SolvingMicroDSOPs.css" /> 
<meta name="src" content="SolvingMicroDSOPs.tex"> 
</head><body 
>
<!--l. 48--><p class="noindent" >                                                                  <span 
class="ecrm-0600">SolvingMicroDSOPs, March 19,</span>
<span 
class="ecrm-0600">2020</span>
  <div class="maketitle">
<h2 class="titleHead">Solution Methods for Microeconomic Dynamic
Stochastic Optimization Problems</h2>
<div class="date" >March 19, 2020</div>
<span 
class="ecrm-0600"> </span>
 <div class="author" ><span 
class="ecrm-1440">Christopher D. Carroll</span><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup></div>
<br />
</div>
<!--l. 64--><p class="indent" >  <a 
 id="Abstract"></a>  <div 
class="abstract" 
>
<!--l. 65--><p class="noindent" > <br 
class="newline" />_____________________________________________________________________________________
<!--l. 65--><p class="noindent" ><span 
class="ecbx-1200">Abstract</span><br 
class="newline" />   <span 
class="ecrm-1095">These notes describe tools for solving microeconomic dynamic stochastic optimization problems,</span>
<span 
class="ecrm-1095">and show how to use those tools for eﬃciently estimating a standard life cycle consumption/saving</span>
<span 
class="ecrm-1095">model using microeconomic data. No attempt is made at a systematic overview of the many possible</span>
<span 
class="ecrm-1095">technical choices; instead, I present a speciﬁc set of methods that have proven useful in my own work</span>
<span 
class="ecrm-1095">(and explain why other popular methods, such as value function iteration, are a bad idea). Paired</span>
<span 
class="ecrm-1095">with these notes is </span><span 
class="ecti-1095">Mathematica </span><span 
class="ecrm-1095">and Matlab software that solves the problems described in the text.</span>
<br 
class="newline" />
        <div class="quote">
                     <dl class="list2"><dt class="list">
<span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> Keywords</span><span 
class="ecbx-1200"> </span></dt><dd 
class="list">
                 <!--l. 75--><p class="noindent" >Dynamic  Stochastic  Optimization,  Method  of  Simulated
                   Moments, Structural Estimation
                   </dd><dt class="list">
<span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> JEL codes</span><span 
class="ecbx-1200"> </span></dt><dd 
class="list">
                 <!--l. 75--><p class="noindent" >E21, F41</dd></dl>
        </div>
                                                                                     
                                                                                     
</div>
<!--l. 89--><p class="indent" >  <div class="center" 
>
  <!--l. 89--><p class="noindent" >
  <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td  
class="tabbing"></td></tr></table>
<!--l. 89--><p class="noindent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> PDF:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs.pdf" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs.pdf</span></a></td></tr></table>
<!--l. 89--><p class="noindent" >       <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> Slides:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs-Slides.pdf" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs-Slides.pdf</span></a></td></tr></table>
<!--l. 89--><p class="noindent" >                 <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> Web:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs/" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs/</span></a></td></tr></table>
<!--l. 89--><p class="noindent" >              <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">Archive:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs.zip" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/SolvingMicroDSOPs.zip</span></a></td></tr></table>
<!--l. 89--><p class="noindent" >     <table  
cellpadding="0" border="0" cellspacing="0" 
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><span 
class="ecti-1000">(Contains LaTeX code for this document and software producing ﬁgures and results)</span></td></tr></table>
<!--l. 89--><p class="noindent" >
</div>
<!--l. 95--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
<!--l. 97--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
      <sup class="textsuperscript"></sup>
<!--l. 94--><p class="indent" >  <sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup><span 
class="ecrm-1000">Carroll: Department of Economics, Johns Hopkins University, Baltimore, MD,</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/</span></a><span 
class="ecrm-1000">, </span><a 
href="mailto:ccarroll@jhu.edu" ><span 
class="ectt-1000">ccarroll@jhu.edu</span></a><span 
class="ecrm-1000">, Phone: (410) 516-7602</span><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span>
      <sup class="textsuperscript"></sup><span 
class="ecrm-1000">The notes were originally written for my Advanced Topics in Macroeconomic Theory class at</span>
<span 
class="ecrm-1000">Johns Hopkins University; instructors elsewhere are welcome to use them for teaching purposes. Relative</span>
<span 
class="ecrm-1000">to earlier drafts, this version incorporates several improvements related to new results in the paper</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/papers/BufferStockTheory.pdf" ><span 
class="ecrm-1000">“Theoretical Foundations of Buﬀer Stock Saving”</span></a> <span 
class="ecrm-1000">(especially tools for approximating the consumption</span>
<span 
class="ecrm-1000">and value functions). Like the last major draft, it also builds on material in “The Method of Endogenous</span>
<span 
class="ecrm-1000">Gridpoints  for  Solving  Dynamic  Stochastic  Optimization  Problems”   published  in  </span><span 
class="ecti-1000">Economics</span>
<span 
class="ecti-1000">Letters</span><span 
class="ecrm-1000">,  available  at  </span><a 
href="http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip</span></a><span 
class="ecrm-1000">,  and</span>
<span 
class="ecrm-1000">by  including  sample  code  for  a  method  of  simulated  moments  estimation  of  the  life  cycle</span>
<span 
class="ecrm-1000">model  </span><span 
class="ecti-1000">a  la  </span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">Gourinchas  and  Parker</span></a><span 
class="ecrm-1000"> (</span><a 
href="#XgpLifecycle"><span 
class="ecrm-1000">2002</span></a><span 
class="ecrm-1000">)  and  Cagetti</span><span 
class="ecrm-1000"> (</span><a 
href="#XcagettiWprofiles"><span 
class="ecrm-1000">2003</span></a><span 
class="ecrm-1000">).  Background  derivations,  notation,</span>
<span 
class="ecrm-1000">and   related   subjects   are   treated   in   my   class   notes   for   ﬁrst   year   macro,   available   at</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption</span></a><span 
class="ecrm-1000">.  I  am  grateful</span>
<span 
class="ecrm-1000">to several generations of graduate students in helping me to reﬁne these notes, to Marc Chan for help</span>
<span 
class="ecrm-1000">in updating the text and software to be consistent with </span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">Carroll</span></a><span 
class="ecrm-1000"> (</span><a 
href="#XcarrollEGM"><span 
class="ecrm-1000">2006</span></a><span 
class="ecrm-1000">), to Kiichi Tokuoka for drafting</span>
<span 
class="ecrm-1000">the section on structural estimation, to Damiano Sandri for exceptionally insightful help in revising and</span>
<span 
class="ecrm-1000">updating the method of simulated moments estimation section, and to Weifeng Wu and Metin Uyanik</span>
<span 
class="ecrm-1000">for revising to be consistent with the ‘method of moderation’ and other improvements. All errors are</span>
<span 
class="ecrm-1000">my own.</span>
                                                                                     
                                                                                     
<!--l. 133--><p class="indent" >  <a 
 id="Introduction"></a>
  <h3 class="sectionHead"><span class="titlemark">1  </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 136--><p class="noindent" >Calculating the mathematically optimal amount to save is a remarkably diﬃcult problem.
Under well-founded assumptions about the nature of risk (and attitudes toward risk), the
problem cannot be solved analytically; computational solutions are the only option. To avoid
having to solve this hard problem, past generations of economists showed impressive ingenuity
in reformulating the question. Budding graduate students are still taught a host of tricks
whose purpose is partly to avoid the resort to numerical solutions: Quadratic or
Constant Absolute Risk Aversion utility, perfect markets, perfect insurance, perfect
foresight, the “timeless” perspective, the restriction of uncertainty to very special
kinds,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a> 
and more.
<!--l. 151--><p class="indent" >  The motivation is mainly to exchange an intractable general problem for a tractable speciﬁc
alternative. Unfortunately, the burgeoning literature on numerical solutions has shown that
the features that yield tractability also profoundly change the solution. These tricks are
excuses to solve a problem that has deﬁned away the central diﬃculty: Understanding the
proper role of uncertainty (and other complexities like constraints) in optimal intertemporal
choice.
<!--l. 159--><p class="indent" >  The temptation to use such tricks (and the tolerance for them in leading academic journals)
is palpably lessening, thanks to advances in mathematical analysis, increasing computing
power, and the growing capabilities of numerical computation software. Together, such tools
permit today’s laptop computers to solve problems that required supercomputers a decade ago
(and, before that, could not be solved at all).
<!--l. 167--><p class="indent" >  These points are not unique to the consumption/saving problem; the same propositions
apply to almost any question that involves both intertemporal choice and uncertainty,
including many aspects of the behavior of ﬁrms and governments.
<!--l. 172--><p class="indent" >  Given the ubiquity of such problems, one might expect that the use of numerical methods
for solving dynamic optimization problems would by now be nearly as common as the use of
econometric methods in empirical work.
<!--l. 177--><p class="indent" >  Of course, we remain far from that equilibrium. The most plausible explanation for the
gap is that barriers to the use of numerical methods have remained forbiddingly
high.
<!--l. 187--><p class="indent" >  These lecture notes provide a gentle introduction to a particular set of solution tools and
show how they can be used to solve some canonical problems in consumption choice and
portfolio allocation. Speciﬁcally, the notes describe and solve optimization problems for a
consumer facing uninsurable idiosyncratic risk to nonﬁnancial income (e.g., labor or transfer
                                                                                     
                                                                                     
income),<span class="footnote-mark"><a 
href="SolvingMicroDSOPs3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-1002f2"></a> 
with detailed intuitive discussion of the various mathematical and computational techniques
that, together, speed the solution by many orders of magnitude compared to “brute
force” methods. The problem is solved with and without liquidity constraints, and
the inﬁnite horizon solution is obtained as the limit of the ﬁnite horizon solution.
After the basic consumption/saving problem with a deterministic interest rate is
described and solved, an extension with portfolio choice between a riskless and a
risky asset is also solved. Finally, a simple example is presented of how to use these
methods (via the statistical ‘method of simulated moments’ or MSM; sometimes called
‘simulated method of moments’ or SMM) to estimate structural parameters like
the coeﬃcient of relative risk aversion (<span 
class="ecti-1200">a la </span>Gourinchas and Parker (<a 
href="#XgpLifecycle">2002</a>) and
Cagetti (<a 
href="#XcagettiWprofiles">2003</a>)).
<!--l. 218--><p class="indent" >  <a 
 id="The-Problem"></a>
  <h3 class="sectionHead"><span class="titlemark">2  </span> <a 
 id="x1-20002"></a>The Problem</h3>
<!--l. 220--><p class="noindent" >We are interested in the behavior a consumer whose goal in period <img 
src="SolvingMicroDSOPs0x.svg" alt="t  " class="math";align="absmiddle"> is to maximize expected
discounted utility from consumption over the remainder of a lifetime that ends in period <img 
src="SolvingMicroDSOPs1x.svg" alt="T  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td><a 
 id="x1-2001r1"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs2x.svg" alt="       [               ]
         T∑− t
max  𝔼t      βn𝜃u (ct+n)  ,
         n𝜃=0
" class="math-display" ></center></td><td class="equation-label">(1)</td></tr></table>
<!--l. 3--><p class="nopar" >
and whose circumstances evolve according to the transition
                                                                                     
                                                                                     
equations<span class="footnote-mark"><a 
href="SolvingMicroDSOPs4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-2002f3"></a> 
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs3x.svg" alt="   a   =   m  − c                                 (2)
    t       t    t
 bt+1  =   atRt+1                                  (3)
 y     =  ppp  𝜃                                   (4)
  t+1       t+1 t+1
mt+1   =   bt+1 + yt+1                             (5)
" class="math-display" ><a 
 id="x1-2003r2"></a><a 
 id="x1-2003r5"></a></center>
</div> where the variables are
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs4x.svg" alt="  β   −  pure time  discount factor
  at  −  assets after all actions have been accomplished in period t

bt+1  −  ‘bank  balances ’ (nonhuman  wealth) at the beginning of t + 1
  ct  −  consumption   in period t
 m    −  ‘market  resources’ available for consumption  (‘cash-on-hand ’)
   t
pppt+1  −  ‘permanent  labor income ’ in period t + 1
R     −  interest factor (1 + r ) from  period t to t + 1
 t+1                         t+1
yt+1  −  noncapital income  in period t + 1.
" class="math-display" ></center>
</div>
                                                                                     
                                                                                     
<!--l. 254--><p class="indent" >  For now, we will assume that the exogenous variables evolve as follows:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs5x.svg" alt="     Rt =        R ∀ t      - constant interest factor = 1 + r
    pppt+1 =       Γ t+1pppt     - permanent  labor income  dynamics          (6)
                   2    2
log  𝜃t+n ∼    𝒩 (− σ 𝜃∕2,σ𝜃) - lognormal  transitory shocks ∀ n &#x003E;  0.
" class="math-display" ><a 
 id="x1-2005r6"></a><a 
 id="x1-2005r7"></a></center>
</div>
<!--l. 267--><p class="indent" >  Using the fact about lognormally distributed variables
<a 
href="http://econ.jhu.edu/people/ccarroll/public/lecturenotes/MathFactsList/ELogNorm" ><span 
class="ectt-1200">ELogNorm</span></a><span class="footnote-mark"><a 
href="SolvingMicroDSOPs5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-2006f4"></a> 
that if <img 
src="SolvingMicroDSOPs7x.svg" alt="log Φ ∼ 𝒩  (ϕ,σ2ϕ)  " class="math";align="absmiddle"> then <img 
src="SolvingMicroDSOPs8x.svg" alt="log 𝔼 [Φ ] = ϕ + σ2ϕ∕2  " class="math";align="absmiddle">, assumption (<a 
href="#x1-2005r7">7<!--tex4ht:ref: eq:epsdist --></a>) guarantees that
<img 
src="SolvingMicroDSOPs9x.svg" alt="log 𝔼[𝜃] = 0  " class="math";align="absmiddle"> which means that <img 
src="SolvingMicroDSOPs10x.svg" alt="𝔼[𝜃]  " class="math";align="absmiddle">=1 (the mean value of the transitory shock is
1).
<!--l. 276--><p class="indent" >  Equation (<a 
href="#x1-2005r6">6<!--tex4ht:ref: eq:permincgrow --></a>) indicates that we are allowing for a predictable average proﬁle of
income growth over the lifetime <img 
src="SolvingMicroDSOPs11x.svg" alt="{Γ }T0   " class="math";align="absmiddle"> (allowing, for example, for typical career wage
paths).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-2007f5"></a> 
<!--l. 293--><p class="indent" >  Finally, the utility function is of the Constant Relative Risk Aversion (CRRA), form,
<img 
src="SolvingMicroDSOPs12x.svg" alt="u (∙ ) = ∙1− ρ∕(1 − ρ )  " class="math";align="absmiddle">.
<!--l. 296--><p class="indent" >  As is well known, this problem can be rewritten in recursive (Bellman equation)
form
<div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs13x.svg" alt="vt(mt,pppt)  =  maxct  u(ct) + 𝔼t[βvt+1(mt+1, pppt+1)]              (7)
" class="math-display" ><a 
 id="x1-2008r7"></a></center>
</div> subject to the Dynamic Budget Constraint (DBC) (<a 
href="#x1-2003r2">2<!--tex4ht:ref: DBCLevelStart --></a>)-(<a 
href="#x1-2003r5">5<!--tex4ht:ref: DBCLevelEnd --></a>) given above, where <img 
src="SolvingMicroDSOPs14x.svg" alt="vt  " class="math";align="absmiddle"> measures
total expected discounted utility from behaving optimally now and henceforth.
<!--l. 307--><p class="indent" >  <a 
 id="Normalization"></a>
  <h3 class="sectionHead"><span class="titlemark">3  </span> <a 
 id="x1-30003"></a>Normalization</h3>
<!--l. 311--><p class="noindent" >The single most powerful method for speeding the solution of such models is to redeﬁne the
problem in a way that reduces the number of state variables (if possible). In the consumption
problem here, the obvious idea is to see whether the problem can be rewritten in terms of the
ratio of various variables to permanent noncapital (‘labor’) income <img 
src="SolvingMicroDSOPs15x.svg" alt="pppt  " class="math";align="absmiddle"> (henceforth for brevity
referred to simply as ‘permanent income.’)
<!--l. 321--><p class="indent" >  In the last period of life, there is no future, <img 
src="SolvingMicroDSOPs16x.svg" alt="v     = 0
  T+1  " class="math";align="absmiddle">, so the optimal plan is to consume
everything, implying that <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs17x.svg" alt="                 m1T−ρ-
vT (mT ,pppT)  =   1 − ρ.                            (8)
" class="math-display" ><a 
 id="x1-3001r8"></a></center>
</div>Now deﬁne nonbold variables as the bold variable divided by the level of permanent
income in the same period, so that, for example, <img 
src="SolvingMicroDSOPs18x.svg" alt="mT  =  mT ∕pppT  " class="math";align="absmiddle">; and deﬁne
<img 
src="SolvingMicroDSOPs19x.svg" alt="vT (mT ) = u(mT )  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-3002f6"></a> 
For our CRRA utility function, <img 
src="SolvingMicroDSOPs22x.svg" alt="u(xy) = x1−ρu (y)  " class="math";align="absmiddle">, so equation (<a 
href="#x1-3001r8">8<!--tex4ht:ref: eq:levelTm1 --></a>) can be rewritten as
<div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs23x.svg" alt="                     m1 −ρ            m1 −ρ
vT(mT  ,pppT)  =  ppp1T− ρ--T---= ppp1T−−ρ1Γ 1T−ρ--T---= ppp1−T−ρ1Γ 1T−ρvT (mT ).
                     1 − ρ            1 − ρ
" class="math-display" ></center>
</div>
<!--l. 337--><p class="indent" >  Now deﬁne a new optimization problem:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs24x.svg" alt="                                 1− ρ
vt(mt )  =    macxt   u(ct) + 𝔼t[βΓ t+1 vt+1 (mt+1 )]                (9)
         s.t.

     at  =    mt − ct
  m      =    (R ∕Γ   )a  + 𝜃
    t+1       ◟--◝t◜+1◞  t   t+1
               ≡ ℛt+1
" class="math-display" ><a 
 id="x1-3004r9"></a></center>
</div>
<!--l. 349--><p class="indent" >  The accumulation equation is the normalized version of the transition equation for
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs25x.svg" alt="mt+1   " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-3005f7"></a> 
Then it is easy to see that for <img 
src="SolvingMicroDSOPs27x.svg" alt="t = T − 1  " class="math";align="absmiddle">, <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs28x.svg" alt="                        1−ρ
vT −1(mT −1,pppT− 1)  =   pppT−1vT −1(mT −1)
" class="math-display" ></center>
</div>and so on back to all earlier periods. Hence, if we solve the problem (<a 
href="#x1-3004r9">9<!--tex4ht:ref: vtNorm --></a>) which has only a single
state variable <img 
src="SolvingMicroDSOPs29x.svg" alt="mt  " class="math";align="absmiddle">, we can obtain the levels of the value function, consumption, and all other
variables of interest simply by multiplying the results by the appropriate function of <img 
src="SolvingMicroDSOPs30x.svg" alt="pppt  " class="math";align="absmiddle">,
e.g. <img 
src="SolvingMicroDSOPs31x.svg" alt="c (m  ,ppp ) = ppp c(m  ∕ppp )
 t  t  t     t t  t  t  " class="math";align="absmiddle"> or <img 
src="SolvingMicroDSOPs32x.svg" alt="v  (m  ,ppp ) = ppp1−ρv (m )
  t  t  t     t   t   t  " class="math";align="absmiddle">. We have thus reduced the problem
from two continuous state variables to one (and thereby enormously simpliﬁed its
solution).
<!--l. 367--><p class="indent" >  For some problems it will not be obvious that there is an appropriate ‘normalizing’ variable,
but many problems can be normalized if suﬃcient thought is given. For example,
<a 
href="#Xvalencia:2006">Valencia</a> (<a 
href="#Xvalencia:2006">2006</a>) shows how a bank’s optimization problem can be normalized by the level of
the bank’s productivity.
<!--l. 377--><p class="indent" >  <a 
 id="The-Usual-Theory"></a>
                                                                                     
                                                                                     
  <h3 class="sectionHead"><span class="titlemark">4  </span> <a 
 id="x1-40004"></a>The Usual Theory, and A Bit More Notation</h3>
<!--l. 382--><p class="noindent" >The ﬁrst order condition for (<a 
href="#x1-3004r9">9<!--tex4ht:ref: vtNorm --></a>) with respect to <img 
src="SolvingMicroDSOPs33x.svg" alt="ct  " class="math";align="absmiddle"> is <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs34x.svg" alt=" ′                   1−ρ ′
u (ct)  =   𝔼t[βℛt+1 Γt+1vt+1(mt+1 )]
       =   𝔼t[βR   Γ −t+1ρv′t+1 (mt+1 )]                     (10)
" class="math-display" ><a 
 id="x1-4001r10"></a></center>
</div>and because the <a 
href="http://econ.jhu.edu/people/ccarroll/public/lecturenotes/consumption/Envelope" ><span 
class="ectt-1200">Envelope</span></a> theorem tells us that <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs35x.svg" alt=" ′                 −ρ  ′
vt(mt ) =   𝔼t[βR Γt+1vt+1(mt+1)]                      (11)
" class="math-display" ><a 
 id="x1-4002r11"></a></center>
</div>we can substitute the LHS of (<a 
href="#x1-4002r11">11<!--tex4ht:ref: eq:envelope --></a>) for the RHS of (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) to get
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs36x.svg" alt=" ′          ′
u (ct)  =   vt(mt)                              (12)
" class="math-display" ><a 
 id="x1-4003r12"></a></center>
</div> and rolling this equation forward one period yields <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs37x.svg" alt=" ′            ′
u (ct+1)  =   vt+1 (atℛt+1 +  𝜃t+1)                       (13)
" class="math-display" ><a 
 id="x1-4004r13"></a></center>
</div>while substituting the LHS in equation (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) gives us the Euler equation for consumption
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs38x.svg" alt=" ′                −ρ  ′
u (ct)  =   𝔼t[βRΓ t+1u (ct+1)].                        (14)
" class="math-display" ><a 
 id="x1-4005r14"></a></center>
</div>
<!--l. 412--><p class="indent" >  Now note that in equation (<a 
href="#x1-4004r13">13<!--tex4ht:ref: eq:upctp1EqVpxtp1 --></a>) neither <img 
src="SolvingMicroDSOPs39x.svg" alt="mt  " class="math";align="absmiddle"> nor <img 
src="SolvingMicroDSOPs40x.svg" alt="ct  " class="math";align="absmiddle"> has any <span 
class="ecti-1200">direct </span>eﬀect on <img 
src="SolvingMicroDSOPs41x.svg" alt="vt+1   " class="math";align="absmiddle"> - only
the diﬀerence between them (i.e. unconsumed market resources or ‘assets’ <img 
src="SolvingMicroDSOPs42x.svg" alt="at  " class="math";align="absmiddle">)
matters. It is therefore possible (and will turn out to be convenient) to deﬁne a
function<span class="footnote-mark"><a 
href="SolvingMicroDSOPs9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-4006f8"></a> 
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs43x.svg" alt="𝔳t(at) =   𝔼t[βΓ 1−t+1ρvt+1 (ℛt+1at  + 𝜃t+1 )]                   (15)
" class="math-display" ><a 
 id="x1-4007r15"></a></center>
</div> that returns the expected <img 
src="SolvingMicroDSOPs44x.svg" alt="t + 1  " class="math";align="absmiddle"> value associated with ending period <img 
src="SolvingMicroDSOPs45x.svg" alt="t  " class="math";align="absmiddle"> with any given
amount of  assets. This deﬁnition implies that <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs46x.svg" alt="  ′                −ρ ′
𝔳 t(at)  =  𝔼t [βR Γ t+1vt+1(ℛt+1at + 𝜃t+1)]                  (16)
" class="math-display" ><a 
 id="x1-4008r16"></a></center>
</div>or, substituting from equation (<a 
href="#x1-4004r13">13<!--tex4ht:ref: eq:upctp1EqVpxtp1 --></a>), <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs47x.svg" alt="𝔳′(at)  =   𝔼t[βR Γ − ρu′(ct+1(ℛt+1at + 𝜃t+1))].              (17)
 t                t+1
" class="math-display" ><a 
 id="x1-4009r17"></a></center>
</div>Finally, note for future use that the ﬁrst order condition (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>) can now be rewritten
as
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs48x.svg" alt="u′(c )  =  𝔳′(m  − c ).                           (18)
   t       t   t   t
" class="math-display" ><a 
 id="x1-4010r18"></a></center>
</div>
<!--l. 447--><p class="indent" >  <a 
 id="Solving-the-Next-To-Last-Period"></a>
  <h3 class="sectionHead"><span class="titlemark">5  </span> <a 
 id="x1-50005"></a>Solving the Next-to-Last Period</h3>
<!--l. 450--><p class="noindent" >The problem in the second-to-last period of life is: <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs49x.svg" alt="                                        [ 1−ρ                           ]
vT−1(mT −1)  =   mcaTx−1  u(cT−1) + β 𝔼T −1 ΓT  vT ((mT − 1 − cT− 1)ℛT + 𝜃T ) ,
" class="math-display" ></center>
</div>and using (1) the fact that <img 
src="SolvingMicroDSOPs50x.svg" alt="v  =  u(c)
 T  " class="math";align="absmiddle">; (2) the deﬁnition of <img 
src="SolvingMicroDSOPs51x.svg" alt="u(c)  " class="math";align="absmiddle">; (3) the deﬁnition of the
expectations operator, and (4) the fact that <img 
src="SolvingMicroDSOPs52x.svg" alt="Γ T  " class="math";align="absmiddle"> is nonstochastic, this becomes
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs53x.svg" alt="                                      ∫
                        c1T−−ρ1      1− ρ  ∞  ((mT − 1 − cT −1)ℛT + 𝜃)1− ρ
vT −1(mT −1)  =   mcax   ------+ βΓ T       --------------------------dℱ (𝜃)
                   T−1  1 − ρ          0             1 − ρ
" class="math-display" ></center>
</div>where <img 
src="SolvingMicroDSOPs54x.svg" alt="ℱ " class="math";align="absmiddle"> is the cumulative distribution function for <img 
src="SolvingMicroDSOPs55x.svg" alt="𝜃  " class="math";align="absmiddle">.
<!--l. 467--><p class="indent" >  In principle, the maximization implicitly deﬁnes a function  <img 
src="SolvingMicroDSOPs56x.svg" alt="cT−1(mT −1)  " class="math";align="absmiddle"> that yields
optimal consumption in period <img 
src="SolvingMicroDSOPs57x.svg" alt="T − 1  " class="math";align="absmiddle"> for any given level of resources <img 
src="SolvingMicroDSOPs58x.svg" alt="mT − 1   " class="math";align="absmiddle">. Unfortunately,
however, there is no general analytical solution to this maximization problem, and so for any
given <img 
src="SolvingMicroDSOPs59x.svg" alt="mT −1   " class="math";align="absmiddle"> we must use numerical computational tools to ﬁnd the <img 
src="SolvingMicroDSOPs60x.svg" alt="cT−1   " class="math";align="absmiddle"> that maximizes
the expression. This is excruciatingly slow because for every potential <img 
src="SolvingMicroDSOPs61x.svg" alt="cT−1   " class="math";align="absmiddle"> to be
considered, the integral must be calculated numerically, and numerical integration is <span 
class="ecti-1200">very</span>
slow.
<!--l. 477--><p class="indent" >  <a 
 id="Discretizing-the-Distribution"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.1  </span> <a 
 id="x1-60005.1"></a>Discretizing the Distribution</h4>
<!--l. 479--><p class="noindent" >Our ﬁrst time-saving step is therefore to construct a discrete approximation to the lognormal
distribution that can be used in place of numerical integration. We calculate an <img 
src="SolvingMicroDSOPs62x.svg" alt="n  " class="math";align="absmiddle">-point
approximation as follows.
<!--l. 487--><p class="indent" >  Deﬁne a set of points from <img 
src="SolvingMicroDSOPs63x.svg" alt="♯0   " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs64x.svg" alt="♯n𝜃   " class="math";align="absmiddle"> on the <img 
src="SolvingMicroDSOPs65x.svg" alt="[0,1]  " class="math";align="absmiddle"> interval as the elements of the set
<img 
src="SolvingMicroDSOPs66x.svg" alt="♯ = {0,1 ∕n,2∕n, ...,1} " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-6001f9"></a> 
Call the inverse of the <img 
src="SolvingMicroDSOPs68x.svg" alt="𝜃  " class="math";align="absmiddle"> distribution <img 
src="SolvingMicroDSOPs69x.svg" alt="  −1
ℱ   " class="math";align="absmiddle">, and deﬁne the points <img 
src="SolvingMicroDSOPs70x.svg" alt=" −1     −1
♯i  = ℱ   (♯i)  " class="math";align="absmiddle">. Then the
                                                                                     
                                                                                     
conditional mean of <img 
src="SolvingMicroDSOPs71x.svg" alt="𝜃  " class="math";align="absmiddle"> in each of the intervals numbered 1 to <img 
src="SolvingMicroDSOPs72x.svg" alt="n  " class="math";align="absmiddle"> is: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs73x.svg" alt="                            ∫  ♯−i1
𝜃i ≡ 𝔼[𝜃|♯−i−11 ≤ 𝜃 &#x003C; ♯−i1]  =        𝜗 dℱ  (𝜗 ).                (19)
                              ♯−i1−1
" class="math-display" ></center>
</div>
<!--l. 495--><p class="indent" >  The method is illustrated in Figure <a 
href="#x1-60041">1<!--tex4ht:ref: fig:discreteapprox --></a>. The solid continuous curve represents the “true” CDF
<img 
src="SolvingMicroDSOPs74x.svg" alt="ℱ  (𝜃)  " class="math";align="absmiddle"> for a lognormal distribution such that <img 
src="SolvingMicroDSOPs75x.svg" alt="𝔼[𝜃] = 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs76x.svg" alt="σ  = 0.1
 𝜃  " class="math";align="absmiddle">. The short vertical line
segments represent the <img 
src="SolvingMicroDSOPs77x.svg" alt="n 𝜃  " class="math";align="absmiddle"> equiprobable values of <img 
src="SolvingMicroDSOPs78x.svg" alt="𝜃i  " class="math";align="absmiddle"> which are used to approximate this
distribution.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-6003f10"></a> 
<a 
 id="discreteApprox"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-60041"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/discreteApprox.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 1: </span><span  
class="content">Discrete Approximation to Lognormal Distribution <img 
src="SolvingMicroDSOPs79x.svg" alt="ℱ " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-60041 -->
                                                                                     
                                                                                     
  </div>
<!--l. 512--><p class="indent" >  Recalling our deﬁnition of <img 
src="SolvingMicroDSOPs80x.svg" alt="𝔳t(at)  " class="math";align="absmiddle">, for <img 
src="SolvingMicroDSOPs81x.svg" alt="t = T −  1  " class="math";align="absmiddle">
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs82x.svg" alt="                      (   ) ∑n𝜃               1−ρ
𝔳T−1(aT− 1)  =   βΓ 1− ρ  -1-     (ℛT-aT-−1 +-𝜃i)---              (20)
                   T    n𝜃            1 − ρ
                             i=1
" class="math-display" ><a 
 id="x1-6005r20"></a></center>
</div> so we can rewrite the maximization problem as
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs83x.svg" alt="                      {                           }
                        c1T−−ρ1--
vT− 1(mT − 1) =   mcaTx−1   1 − ρ + 𝔳T−1(mT −1 − cT− 1)   .           (21)
" class="math-display" ><a 
 id="x1-6006r21"></a></center>
</div>
  <h4 class="subsectionHead"><span class="titlemark">5.2  </span> <a 
 id="x1-70005.2"></a>The Approximate Consumption and Value Functions</h4>
<!--l. 534--><p class="noindent" >Given a particular value of <img 
src="SolvingMicroDSOPs84x.svg" alt="mT −1   " class="math";align="absmiddle">, a numerical maximization routine can now ﬁnd the <img 
src="SolvingMicroDSOPs85x.svg" alt="cT−1   " class="math";align="absmiddle">
that maximizes (<a 
href="#x1-6006r21">21<!--tex4ht:ref: eq:vEndTm1 --></a>) in a reasonable amount of time. The <span 
class="ecti-1200">Mathematica </span>program that solves
exactly this problem is called <span 
class="ectt-1200">2period.m</span>. (The archive also contains parallel Matlab programs,
but these notes will dwell on the speciﬁcs of the <span 
class="ecti-1200">Mathematica </span>implementation, which is
superior in many respects.)
<!--l. 541--><p class="indent" >  The ﬁrst thing <span 
class="ectt-1200">2period.m </span>does is to read in the ﬁle <span 
class="ectt-1200">functions.m </span>which contains
deﬁnitions of the consumption and value functions; <span 
class="ectt-1200">functions.m </span>also deﬁnes the function
<span 
class="ectt-1200">SolveAnotherPeriod </span>which, given the existence in memory of a solution for period <img 
src="SolvingMicroDSOPs86x.svg" alt="t + 1  " class="math";align="absmiddle">,
solves for period <img 
src="SolvingMicroDSOPs87x.svg" alt="t  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
<!--l. 547--><p class="indent" >  The next step is to run the programs <span 
class="ectt-1200">setup_params.m</span>, <span 
class="ectt-1200">setup_grids.m</span>, <span 
class="ectt-1200">setup_shocks.m</span>,
respectively. <span 
class="ectt-1200">setup_params.m </span>sets values for the parameter values like the coeﬃcient of
relative risk aversion. <span 
class="ectt-1200">setup_shocks.m </span>calculates the values for the <img 
src="SolvingMicroDSOPs88x.svg" alt="𝜃i  " class="math";align="absmiddle"> deﬁned above (and
puts those values, and the (identical) probability associated with each of them, in the vector
variables <img 
src="SolvingMicroDSOPs89x.svg" alt="𝜃   " class="math";align="absmiddle"><span 
class="ectt-1200">Vals </span>and <img 
src="SolvingMicroDSOPs90x.svg" alt="𝜃   " class="math";align="absmiddle"><span 
class="ectt-1200">Prob</span>). Finally, <span 
class="ectt-1200">setup_grids.m </span>constructs a list of potential values
of cash-on-hand and saving, then puts them in the vector variables <span 
class="ectt-1200">mVec </span>= <span 
class="ectt-1200">aVec </span>=
<img 
src="SolvingMicroDSOPs91x.svg" alt="{0, 1,2,3,4} " class="math";align="absmiddle"> respectively. Then <span 
class="ectt-1200">2period.m </span>runs the program <span 
class="ectt-1200">setup_lastperiod.m </span>which
deﬁnes the elements necessary to determine behavior in the last period, in which <img 
src="SolvingMicroDSOPs92x.svg" alt="cT(m ) = m  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs93x.svg" alt="vT(m ) = u(m )  " class="math";align="absmiddle">.
<!--l. 561--><p class="indent" >  After all the setup, the only remaining step in <span 
class="ectt-1200">2period.m </span>is to invoke <span 
class="ectt-1200">SolveAnotherPeriod</span>,
which constructs the solution for period <img 
src="SolvingMicroDSOPs94x.svg" alt="T − 1  " class="math";align="absmiddle"> given the presence of the solution for period
<img 
src="SolvingMicroDSOPs95x.svg" alt="T  " class="math";align="absmiddle"> (constructed by <span 
class="ectt-1200">setup_lastperiod.m</span>).
<!--l. 566--><p class="indent" >  Because we will always be comparing our solution to the perfect foresight solution, we also
construct the variables required to characterize the perfect foresight consumption function in
periods prior to <img 
src="SolvingMicroDSOPs96x.svg" alt="T  " class="math";align="absmiddle">. In particular, we construct the list <span 
class="ectt-1200">yExpPDV </span>(which contains the PDV of
expected income – ‘expected human wealth’), and <span 
class="ectt-1200">yMinPDV </span>which contains the minimum possible
discounted value of future income at the beginning of period <img 
src="SolvingMicroDSOPs97x.svg" alt="T −  1  " class="math";align="absmiddle"> (‘minimum human
wealth’).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs12.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-7001f11"></a> 
<!--l. 577--><p class="indent" >  The perfect foresight consumption function is also constructed (<span 
class="ectt-1200">setup_PerfectForesightSolution.m</span>).
This program uses the fact that, in <span 
class="ecti-1200">Mathematica</span>, functions can be saved as objects using the
commands <span 
class="ectt-1200"># </span>and <span 
class="ectt-1200">&#x0026;</span>. The <span 
class="ectt-1200"># </span>denotes the argument of the function, while the <span 
class="ectt-1200">&#x0026;</span>, placed at the end
of the function, tells <span 
class="ecti-1200">Mathematica </span>that the function should be saved as an object. In the
program, the last period perfect foresight consumption function is saved as an element in the
list <img 
src="SolvingMicroDSOPs98x.svg" alt="cг   " class="math";align="absmiddle">  <span 
class="ectt-1200">= {(# - 1 + Last[yExpPDV]) Last[</span><img 
src="SolvingMicroDSOPs99x.svg" alt="κ   " class="math";align="absmiddle"><span 
class="ectt-1200">Min] &#x0026;}</span>, where <span 
class="ectt-1200">Last[yExpPDV]</span>
gives the just-constructed PDV of human wealth at the beginning of <img 
src="SolvingMicroDSOPs100x.svg" alt="T  " class="math";align="absmiddle"> (equal to
1, since current income is included in <img 
src="SolvingMicroDSOPs101x.svg" alt="hT  " class="math";align="absmiddle">), and <span 
class="ectt-1200">Last[</span><img 
src="SolvingMicroDSOPs102x.svg" alt="κ   " class="math";align="absmiddle"><span 
class="ectt-1200">Min] </span>gives the perfect
foresight marginal propensity to consume (equal to 1, since it is optimal to spend all
resources in the last period). Since <span 
class="ectt-1200"># </span>in the code stands in for what was called <img 
src="SolvingMicroDSOPs103x.svg" alt="m  " class="math";align="absmiddle"> in
the model, the discounted total wealth is decomposed into discounted non-human
wealth <span 
class="ectt-1200"># - 1 </span>and discounted human wealth <span 
class="ectt-1200">Last[yExpPDV]</span>. The resulting formula
then corresponds to <img 
src="SolvingMicroDSOPs104x.svg" alt="¯cT = (mT −  1 + hT)κT  " class="math";align="absmiddle">, which translates to <img 
src="SolvingMicroDSOPs105x.svg" alt="¯cT = mT  " class="math";align="absmiddle"> for
<img 
src="SolvingMicroDSOPs106x.svg" alt="hT =  κ- = 1
       T  " class="math";align="absmiddle">.
<!--l. 598--><p class="indent" >  The inﬁnite horizon perfect foresight marginal propensity to save <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs107x.svg" alt="                 1∕ρ
λ  =   (1∕R)(Rβ )                               (22)
" class="math-display" ><a 
 id="x1-7002r22"></a></center>
</div>is also deﬁned because it will be useful in a number of
derivations.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs13.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-7003f12"></a> 
<!--l. 605--><p class="indent" >  The program then constructs behavior for one iteration back from the last period of life by
using the function <span 
class="ectt-1200">AddNewPeriodToParamLifeDates</span>. Using the <span 
class="ecti-1200">Mathematica</span> command
<span 
class="ectt-1200">AppendTo</span>, various existing lists (which characterized the solution for period <img 
src="SolvingMicroDSOPs108x.svg" alt="T  " class="math";align="absmiddle">) are redeﬁned
to include an additional element representing the relevant formulas in the second to last period
of life. For example, <img 
src="SolvingMicroDSOPs109x.svg" alt="κ   " class="math";align="absmiddle"><span 
class="ectt-1200">Min </span>now has two elements. The second element, given by <span 
class="ectt-1200">1/(1 +</span>
<span 
class="ectt-1200">Last[</span><img 
src="SolvingMicroDSOPs110x.svg" alt="λ   " class="math";align="absmiddle"><span 
class="ectt-1200">]/Last[</span><img 
src="SolvingMicroDSOPs111x.svg" alt="κ   " class="math";align="absmiddle"><span 
class="ectt-1200">Min])</span>, is the perfect foresight marginal propensity to consume in
<img 
src="SolvingMicroDSOPs112x.svg" alt="t = T − 1  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs14.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-7004f13"></a> 
<!--l. 617--><p class="indent" >  Next, the program deﬁnes a function <img 
src="SolvingMicroDSOPs113x.svg" alt="𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">[at_] </span>(in <span 
class="ectt-1200">functions_stable.m</span>) which  is the
exact implementation of (<a 
href="#x1-4007r15">15<!--tex4ht:ref: eq:vEndtdefn --></a>): It returns the expectation of the value of behaving
optimally in period <img 
src="SolvingMicroDSOPs114x.svg" alt="T  " class="math";align="absmiddle"> given any speciﬁc amount of assets at the end of <img 
src="SolvingMicroDSOPs115x.svg" alt="T − 1  " class="math";align="absmiddle">,
<img 
src="SolvingMicroDSOPs116x.svg" alt="aT −1   " class="math";align="absmiddle">.
<!--l. 625--><p class="indent" >  The heart of the program is the next expression (in <span 
class="ectt-1200">functions.m</span>). This expression loops
over the values of the variable <span 
class="ectt-1200">mVec</span>, solving the maximization problem (given in equation
(<a 
href="#x1-6006r21">21<!--tex4ht:ref: eq:vEndTm1 --></a>)): <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs117x.svg" alt="maxc     u[c ] + 𝔳 [mVec[ [i]]- c]                      (23)
" class="math-display" ><a 
 id="x1-7005r23"></a></center>
</div>for each of the <img 
src="SolvingMicroDSOPs118x.svg" alt="i  " class="math";align="absmiddle"> values of <span 
class="ectt-1200">mVec </span>(henceforth let’s call these points <img 
src="SolvingMicroDSOPs119x.svg" alt="mT −1,i  " class="math";align="absmiddle">).  The
maximization routine returns two values: the maximized value, and the value of <img 
src="SolvingMicroDSOPs120x.svg" alt="c  " class="math";align="absmiddle"> which
yields that maximized value. When the loop (the <span 
class="ectt-1200">Table </span>command) is ﬁnished, the variable
<span 
class="ectt-1200">vAndcList </span>contains two lists, one with the values <img 
src="SolvingMicroDSOPs121x.svg" alt="vT− 1,i  " class="math";align="absmiddle"> and the other with the consumption
levels <img 
src="SolvingMicroDSOPs122x.svg" alt="cT− 1,i  " class="math";align="absmiddle"> associated with the <img 
src="SolvingMicroDSOPs123x.svg" alt="mT − 1,i  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">5.3  </span> <a 
 id="x1-80005.3"></a>An Interpolated Consumption Function</h4>
<!--l. 651--><p class="noindent" >Now we use the ﬁrst of the really convenient built-in features of  <span 
class="ecti-1200">Mathematica</span>. Given a set of
points on a function (in this case, the consumption function <img 
src="SolvingMicroDSOPs124x.svg" alt="cT−1(m )  " class="math";align="absmiddle">), <span 
class="ecti-1200">Mathematica</span> can
create an object called an <span 
class="ectt-1200">InterpolatingFunction </span>which when applied to an input <img 
src="SolvingMicroDSOPs125x.svg" alt="m  " class="math";align="absmiddle"> will
yield the value of <img 
src="SolvingMicroDSOPs126x.svg" alt="c  " class="math";align="absmiddle"> that corresponds to a linear interpolation of the value of <img 
src="SolvingMicroDSOPs127x.svg" alt="c  " class="math";align="absmiddle"> from the
points in the <span 
class="ectt-1200">InterpolatingFunction </span>object. We can therefore deﬁne an approximation to
the consumption function <img 
src="SolvingMicroDSOPs128x.svg" alt="`cT−1(mT − 1)  " class="math";align="absmiddle"> which, when called with an <img 
src="SolvingMicroDSOPs129x.svg" alt="mT −1   " class="math";align="absmiddle"> that is equal to
one of the points in <span 
class="ectt-1200">mVec[[i]] </span>returns the associated value of <img 
src="SolvingMicroDSOPs130x.svg" alt="cT−1,i  " class="math";align="absmiddle">, and when called with a
value of <img 
src="SolvingMicroDSOPs131x.svg" alt="mT −1   " class="math";align="absmiddle"> that is not exactly equal to one of the <span 
class="ectt-1200">mVec[[i]]</span>, returns the value of
<img 
src="SolvingMicroDSOPs132x.svg" alt="c  " class="math";align="absmiddle"> that reﬂects a linear interpolation between the <img 
src="SolvingMicroDSOPs133x.svg" alt="cT−1,i  " class="math";align="absmiddle"> associated with the two
<span 
class="ectt-1200">mVec[[i]] </span>points nearest to <img 
src="SolvingMicroDSOPs134x.svg" alt="mT −1   " class="math";align="absmiddle">. Thus if the function is called with <img 
src="SolvingMicroDSOPs135x.svg" alt="mT −1 = 1.75  " class="math";align="absmiddle">
and the nearest gridpoints  are <img 
src="SolvingMicroDSOPs136x.svg" alt="mj,T−1 = 1  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs137x.svg" alt="mk,T− 1 = 2  " class="math";align="absmiddle"> then the value of
<img 
src="SolvingMicroDSOPs138x.svg" alt="cT− 1   " class="math";align="absmiddle"> returned by the function would be <img 
src="SolvingMicroDSOPs139x.svg" alt="(0.25cj,T− 1 + 0.75ck,T−1)  " class="math";align="absmiddle">. We can deﬁne a
numerical approximation to the value function <img 
src="SolvingMicroDSOPs140x.svg" alt="`vT−1(mT −1)  " class="math";align="absmiddle"> in an exactly analogous
way.
<!--l. 679--><p class="indent" >  Figures <a 
href="#x1-80022">2<!--tex4ht:ref: fig:PlotcTm1Simple --></a> and <a 
href="#x1-80033">3<!--tex4ht:ref: fig:PlotVTm1Simple --></a> show plots of the <img 
src="SolvingMicroDSOPs141x.svg" alt="`cT−1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs142x.svg" alt="`vT−1   " class="math";align="absmiddle"> <span 
class="ectt-1200">InterpolatingFunctions </span>that are generated
by the program <span 
class="ectt-1200">2PeriodInt.m</span>. While the <img 
src="SolvingMicroDSOPs143x.svg" alt="`cT−1   " class="math";align="absmiddle"> function looks very smooth, the fact that the
<img 
src="SolvingMicroDSOPs144x.svg" alt="`v
 T −1   " class="math";align="absmiddle"> function is a set of line segments is very evident. This ﬁgure provides the beginning of
the intuition for why trying to approximate the value function directly is a bad idea (in this
context).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs15.html#fn14x0"><sup class="textsuperscript">14</sup></a></span><a 
 id="x1-8001f14"></a> 
<!--l. 691--><p class="indent" >  <a 
 id="PlotcTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80022"></a>
                                                                                     
                                                                                     
<!--l. 693--><p class="noindent" > <img 
src="./Figures/PlotcTm1Simple.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 2: </span><span  
class="content"><img 
src="SolvingMicroDSOPs145x.svg" alt="cT−1(mT − 1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs146x.svg" alt="`cT− 1(mT  −1)  " class="math";align="absmiddle"> (dashed)</span></div><!--tex4ht:label?: x1-80022 -->
                                                                                     
                                                                                     
  </div>
<!--l. 698--><p class="indent" >  <a 
 id="PlotvTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80033"></a>
                                                                                     
                                                                                     
<!--l. 700--><p class="noindent" > <img 
src="./Figures/PlotVTm1Simple.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 3: </span><span  
class="content"><img 
src="SolvingMicroDSOPs147x.svg" alt="vT− 1   " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs148x.svg" alt="`vT −1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></div><!--tex4ht:label?: x1-80033 -->
                                                                                     
                                                                                     
  </div>
<!--l. 705--><p class="indent" >  <a 
 id="Interpolating-Expectations"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.4  </span> <a 
 id="x1-90005.4"></a>Interpolating Expectations</h4>
<!--l. 710--><p class="noindent" ><span 
class="ectt-1200">2period.m </span>works well in the sense that it generates a good approximation to the true optimal
consumption function. However, there is a clear ineﬃciency in the program: Since it uses
equation (<a 
href="#x1-6006r21">21<!--tex4ht:ref: eq:vEndTm1 --></a>), for every value of <img 
src="SolvingMicroDSOPs149x.svg" alt="mT − 1   " class="math";align="absmiddle"> the program must calculate the utility consequences of
various possible choices of <img 
src="SolvingMicroDSOPs150x.svg" alt="cT −1   " class="math";align="absmiddle"> as it searches for the best choice.  But for any given
value of <img 
src="SolvingMicroDSOPs151x.svg" alt="aT−1   " class="math";align="absmiddle">, there is a good chance that the program may end up calculating the
corresponding <img 
src="SolvingMicroDSOPs152x.svg" alt="𝔳  " class="math";align="absmiddle"> many times while maximizing utility from diﬀerent <img 
src="SolvingMicroDSOPs153x.svg" alt="m
  T−1   " class="math";align="absmiddle">’s. For
example, it is possible that the program will calculate the value of ending the period
with <img 
src="SolvingMicroDSOPs154x.svg" alt="aT −1 = 0  " class="math";align="absmiddle"> dozens of times. It would be much more eﬃcient if the program
could make that calculation once and then merely recall the value when it is needed
again.
<!--l. 727--><p class="indent" >  This can be achieved using the same interpolation technique used above to construct a
direct numerical approximation to the value function: Deﬁne a grid of possible values for
saving at time <img 
src="SolvingMicroDSOPs155x.svg" alt="T − 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs156x.svg" alt="⃗aT −1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">aVec </span>in <span 
class="ectt-1200">setup_grids.m</span>), designating the speciﬁc points
<img 
src="SolvingMicroDSOPs157x.svg" alt="aT −1,i  " class="math";align="absmiddle">; for each of these values of <img 
src="SolvingMicroDSOPs158x.svg" alt="aT −1,i  " class="math";align="absmiddle">, calculate the vector <img 
src="SolvingMicroDSOPs159x.svg" alt="⃗𝔳T−1   " class="math";align="absmiddle"> as the collection of
points <img 
src="SolvingMicroDSOPs160x.svg" alt="𝔳T− 1,i = 𝔳T −1(aT−1,i)  " class="math";align="absmiddle"> using equation (<a 
href="#x1-4007r15">15<!--tex4ht:ref: eq:vEndtdefn --></a>); then construct an <span 
class="ectt-1200">InterpolatingFunction</span>
object <img 
src="SolvingMicroDSOPs161x.svg" alt="`𝔳   (a    )
 T− 1  T−1  " class="math";align="absmiddle"> from the list of points on the function captured in the <img 
src="SolvingMicroDSOPs162x.svg" alt="⃗a
 T −1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs163x.svg" alt="⃗𝔳
  T−1   " class="math";align="absmiddle">
vectors.
<!--l. 741--><p class="indent" >  Thus, we are now interpolating for the function that reveals
the expected value of <span 
class="ecti-1200">ending </span>the period with a given amount of
assets.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs16.html#fn15x0"><sup class="textsuperscript">15</sup></a></span><a 
 id="x1-9001f15"></a> 
The program <span 
class="ectt-1200">2periodIntExp.m </span>solves this problem. Figure <a 
href="#x1-90024">4<!--tex4ht:ref: fig:PlotOTm1RawVSInt --></a> compares the true value
function to the <span 
class="ectt-1200">InterpolatingFunction </span>approximation; the functions are of course identical
at the gridpoints chosen for <img 
src="SolvingMicroDSOPs164x.svg" alt="aT− 1   " class="math";align="absmiddle"> and they appear reasonably close except in the region
below <img 
src="SolvingMicroDSOPs165x.svg" alt="mT −1 = 1  " class="math";align="absmiddle">.
<!--l. 753--><p class="indent" >  <a 
 id="PlotOTm1RawVSInt"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-90024"></a>
                                                                                     
                                                                                     
<!--l. 755--><p class="noindent" > <img 
src="./Figures/PlotOTm1RawVSInt.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 4: </span><span  
class="content">End-Of-Period Value <img 
src="SolvingMicroDSOPs166x.svg" alt="𝔳T −1(aT−1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs167x.svg" alt="`𝔳T− 1(aT −1)  " class="math";align="absmiddle"> (dashed)</span></div><!--tex4ht:label?: x1-90024 -->
                                                                                     
                                                                                     
  </div>
<!--l. 760--><p class="indent" >  <a 
 id="PlotComparecTm1AB"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-90035"></a>
                                                                                     
                                                                                     
<!--l. 762--><p class="noindent" > <img 
src="./Figures/PlotComparecTm1AB.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 5: </span><span  
class="content"><img 
src="SolvingMicroDSOPs168x.svg" alt="cT−1(mT − 1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs169x.svg" alt="`cT− 1(mT  −1)  " class="math";align="absmiddle"> (dashed)</span></div><!--tex4ht:label?: x1-90035 -->
                                                                                     
                                                                                     
  </div>
<!--l. 767--><p class="indent" >  Nevertheless, the resulting consumption rule obtained when <img 
src="SolvingMicroDSOPs170x.svg" alt="`𝔳T−1(aT− 1)  " class="math";align="absmiddle"> is used instead of
<img 
src="SolvingMicroDSOPs171x.svg" alt="𝔳T −1(aT−1)  " class="math";align="absmiddle"> is surprisingly bad, as shown in ﬁgure <a 
href="#x1-90035">5<!--tex4ht:ref: fig:PlotComparecTm1AB --></a>. For example, when <img 
src="SolvingMicroDSOPs172x.svg" alt="mT −1   " class="math";align="absmiddle"> goes
from 2 to 3, <img 
src="SolvingMicroDSOPs173x.svg" alt="`c
 T−1   " class="math";align="absmiddle"> goes from about 1 to about 2, yet when <img 
src="SolvingMicroDSOPs174x.svg" alt="m
  T −1   " class="math";align="absmiddle"> goes from 3 to
4, <img 
src="SolvingMicroDSOPs175x.svg" alt="`cT−1   " class="math";align="absmiddle"> goes from about 2 to about 2.05. The function fails even to be strictly
concave, which is distressing because Carroll and Kimball (<a 
href="#Xcarroll&kimball:concavity">1996</a>) prove that the correct
consumption function is strictly concave in a wide class of problems that includes this
problem.
<!--l. 780--><p class="indent" >  <a 
 id="Value-Function-versus-First-Order-Condition"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.5  </span> <a 
 id="x1-100005.5"></a>Value Function versus First Order Condition</h4>
<!--l. 783--><p class="noindent" >Loosely speaking, our diﬃculty reﬂects the fact that the consumption choice is governed by
the <span 
class="ecti-1200">marginal </span>value function, not by the <span 
class="ecti-1200">level </span>of the value function (which is the object that we
approximated). To understand this point, recall that a quadratic utility function exhibits risk
aversion because with a stochastic <img 
src="SolvingMicroDSOPs176x.svg" alt="c  " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td><a 
 id="x1-10001r24"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs177x.svg" alt="𝔼 [− (c − /c)2] &#x003C; − (𝔼[c] − /c)2
" class="math-display" ></center></td><td class="equation-label">(24)</td></tr></table>
<!--l. 795--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs178x.svg" alt="/c  " class="math";align="absmiddle"> is the ‘bliss point’. However, unlike the CRRA utility function, with quadratic utility
the consumption/saving <span 
class="ecti-1200">behavior </span>of consumers is unaﬀected by risk since behavior is
determined by the ﬁrst order condition, which depends on <span 
class="ecti-1200">marginal </span>utility, and when utility is
quadratic, marginal utility is unaﬀected by risk:
  <table 
class="equation"><tr><td><a 
 id="x1-10002r25"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs179x.svg" alt="𝔼[− 2(c − /c)] = − 2(𝔼[c] − /c).
" class="math-display" ></center></td><td class="equation-label">(25)</td></tr></table>
<!--l. 803--><p class="nopar" >
<!--l. 805--><p class="indent" >  Intuitively, if one’s goal is to accurately capture choices that are governed by marginal
value, numerical techniques that approximate the <span 
class="ecti-1200">marginal </span>value function will yield a more
accurate approximation to optimal behavior than techniques that approximate the <span 
class="ecti-1200">level </span>of the
value function.
<!--l. 812--><p class="indent" >  The ﬁrst order condition of the maximization problem in period <img 
src="SolvingMicroDSOPs180x.svg" alt="T − 1  " class="math";align="absmiddle"> is:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs181x.svg" alt=" ′                    −ρ   ′
u (cT −1) =   β 𝔼T −1[Γ T Ru (cT)]                                  (26)
                (  1 ) ∑n𝜃
   c−T−ρ1 =   R β  ---     Γ −Tρ(R (mT −1 − cT−1) + 𝜃i)−ρ .          (27)
                  n 𝜃  i=1
" class="math-display" ><a 
 id="x1-10003r26"></a><a 
 id="x1-10003r27"></a></center>
</div> <a 
 id="PlotuPrimeVSOPrime"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100046"></a>
                                                                                     
                                                                                     
<!--l. 823--><p class="noindent" > <img 
src="./Figures/PlotuPrimeVSOPrime.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 6: </span><span  
class="content"><img 
src="SolvingMicroDSOPs182x.svg" alt="u′(c)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs183x.svg" alt="𝔳 ′T−1(3 − c),𝔳′T−1(4 − c),`𝔳′T−1(3 − c),`𝔳′T−1(4 − c)  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-100046 -->
                                                                                     
                                                                                     
  </div>
<!--l. 828--><p class="indent" >  The downward-sloping curve in Figure <a 
href="#x1-100046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> shows the value of <img 
src="SolvingMicroDSOPs184x.svg" alt="c−Tρ−1   " class="math";align="absmiddle"> for our baseline
parameter values for <img 
src="SolvingMicroDSOPs185x.svg" alt="0 ≤ cT− 1 ≤ 4  " class="math";align="absmiddle"> (the horizontal axis). The solid upward-sloping curve
shows the value of the RHS of (<a 
href="#x1-10003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) as a function of <img 
src="SolvingMicroDSOPs186x.svg" alt="c
 T −1   " class="math";align="absmiddle"> under the assumption that
<img 
src="SolvingMicroDSOPs187x.svg" alt="mT − 1 = 3  " class="math";align="absmiddle">. Constructing this ﬁgure is rather time-consuming, because for every value of
<img 
src="SolvingMicroDSOPs188x.svg" alt="cT− 1   " class="math";align="absmiddle"> plotted we must calculate the RHS of (<a 
href="#x1-10003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>). The value of <img 
src="SolvingMicroDSOPs189x.svg" alt="cT− 1   " class="math";align="absmiddle"> for which the RHS and
LHS of (<a 
href="#x1-10003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) are equal is the optimal level of consumption given that <img 
src="SolvingMicroDSOPs190x.svg" alt="mT −1 = 3  " class="math";align="absmiddle">, so the
intersection of the downward-sloping and the upward-sloping curves gives the optimal value of
<img 
src="SolvingMicroDSOPs191x.svg" alt="cT− 1   " class="math";align="absmiddle">. As we can see, the two curves intersect just below <img 
src="SolvingMicroDSOPs192x.svg" alt="cT −1 = 2  " class="math";align="absmiddle">. Similarly, the
upward-sloping dashed curve shows the expected value of the RHS of (<a 
href="#x1-10003r27">27<!--tex4ht:ref: eq:FOCTm1 --></a>) under the
assumption that <img 
src="SolvingMicroDSOPs193x.svg" alt="mT −1 = 4  " class="math";align="absmiddle">, and the intersection of this curve with <img 
src="SolvingMicroDSOPs194x.svg" alt="u ′(cT−1)  " class="math";align="absmiddle"> yields the
optimal level of consumption if <img 
src="SolvingMicroDSOPs195x.svg" alt="mT  −1 = 4  " class="math";align="absmiddle">. These two curves intersect slightly below
<img 
src="SolvingMicroDSOPs196x.svg" alt="cT− 1 = 2.5  " class="math";align="absmiddle">. Thus, increasing <img 
src="SolvingMicroDSOPs197x.svg" alt="mT −1   " class="math";align="absmiddle"> from 3 to 4 increases optimal consumption by about
0.5.
<!--l. 849--><p class="indent" >  Now consider the derivative of our function <img 
src="SolvingMicroDSOPs198x.svg" alt="`𝔳T−1(aT− 1)  " class="math";align="absmiddle">. Because we have constructed
<img 
src="SolvingMicroDSOPs199x.svg" alt="`𝔳T −1   " class="math";align="absmiddle"> as a linear interpolation, the slope of <img 
src="SolvingMicroDSOPs200x.svg" alt="`𝔳T−1(aT− 1)  " class="math";align="absmiddle"> between any two adjacent points
<img 
src="SolvingMicroDSOPs201x.svg" alt="{aT −1,i,ai+1,T− 1} " class="math";align="absmiddle"> is constant. The level of the slope immediately below any particular
gridpoint is diﬀerent, of course, from the slope above that gridpoint, a fact which implies that
the derivative of <img 
src="SolvingMicroDSOPs202x.svg" alt="`𝔳T− 1(aT −1)  " class="math";align="absmiddle"> follows a step function.
<!--l. 859--><p class="indent" >  The solid-line step function in Figure <a 
href="#x1-100046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> depicts the actual value of <img 
src="SolvingMicroDSOPs203x.svg" alt=" ′
`𝔳T−1(3 − cT−1)  " class="math";align="absmiddle">. When
we attempt to ﬁnd optimal values of <img 
src="SolvingMicroDSOPs204x.svg" alt="cT−1   " class="math";align="absmiddle"> given <img 
src="SolvingMicroDSOPs205x.svg" alt="mT −1   " class="math";align="absmiddle"> using <img 
src="SolvingMicroDSOPs206x.svg" alt="`𝔳T −1(aT−1)  " class="math";align="absmiddle">, the numerical
optimization routine will return the <img 
src="SolvingMicroDSOPs207x.svg" alt="cT−1   " class="math";align="absmiddle"> for which <img 
src="SolvingMicroDSOPs208x.svg" alt="u′(cT−1) = `𝔳′T− 1(mT − 1 − cT −1)  " class="math";align="absmiddle">. Thus,
for <img 
src="SolvingMicroDSOPs209x.svg" alt="m     = 3
  T−1  " class="math";align="absmiddle"> the program will return the value of <img 
src="SolvingMicroDSOPs210x.svg" alt="c
 T− 1   " class="math";align="absmiddle"> for which the downward-sloping
<img 
src="SolvingMicroDSOPs211x.svg" alt="  ′
u (cT−1)  " class="math";align="absmiddle"> curve intersects with the <img 
src="SolvingMicroDSOPs212x.svg" alt=" ′
`𝔳T− 1(3 − cT −1)  " class="math";align="absmiddle">; as the diagram shows, this value is
exactly equal to 2. Similarly, if we ask the routine to ﬁnd the optimal <img 
src="SolvingMicroDSOPs213x.svg" alt="cT−1   " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs214x.svg" alt="mT  −1 = 4  " class="math";align="absmiddle">, it
ﬁnds the point of intersection of <img 
src="SolvingMicroDSOPs215x.svg" alt="u ′(cT−1)  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs216x.svg" alt="`𝔳 ′T−1(4 − cT−1)  " class="math";align="absmiddle">; and as the diagram shows,
this intersection is only slightly above 2. Hence, this ﬁgure illustrates why the numerical
consumption function plotted earlier returned values very close to <img 
src="SolvingMicroDSOPs217x.svg" alt="c    = 2
 T−1  " class="math";align="absmiddle"> for both
<img 
src="SolvingMicroDSOPs218x.svg" alt="mT − 1 = 3  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs219x.svg" alt="mT − 1 = 4  " class="math";align="absmiddle">.
<!--l. 878--><p class="indent" >  We would obviously obtain much better estimates of the point of intersection between
<img 
src="SolvingMicroDSOPs220x.svg" alt="u ′(cT−1)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs221x.svg" alt="𝔳′T−1(mT −1 − cT− 1)  " class="math";align="absmiddle"> if our estimate of <img 
src="SolvingMicroDSOPs222x.svg" alt="`𝔳′T− 1   " class="math";align="absmiddle"> were not a step function.
In fact, we already know how to construct linear interpolations to functions, so
the obvious next step is to construct a linear interpolating approximation to the
<span 
class="ecti-1200">expected marginal value of end-of-period assets function</span> <img 
src="SolvingMicroDSOPs223x.svg" alt=" ′
𝔳 " class="math";align="absmiddle">. That is, we calculate
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs224x.svg" alt="                       ( 1 ) ∑n𝜃
𝔳′T−1(aT− 1) =   βR Γ −T ρ ---     (ℛT aT− 1 + 𝜃i)−ρ             (28)
                         n𝜃   i=1
" class="math-display" ><a 
 id="x1-10005r28"></a></center>
</div>at the points in <span 
class="ectt-1200">aVec </span>yielding <img 
src="SolvingMicroDSOPs225x.svg" alt="{{aT −1,1,𝔳′T −1,1},{aT −1,2,𝔳′T− 1,2}...} " class="math";align="absmiddle"> and construct
<img 
src="SolvingMicroDSOPs226x.svg" alt="`𝔳′   (a   )
 T −1  T−1  " class="math";align="absmiddle"> as the linear interpolating function that ﬁts this set of points.
<!--l. 895--><p class="indent" >  <a 
>PlotOPRawVSFOC</a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100067"></a>
                                                                                     
                                                                                     
<!--l. 897--><p class="noindent" > <img 
src="./Figures/PlotOPRawVSFOC.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 7: </span><span  
class="content"><img 
src="SolvingMicroDSOPs227x.svg" alt="𝔳′T− 1(aT −1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs228x.svg" alt="`𝔳′T−1(aT− 1)  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-100067 -->
                                                                                     
                                                                                     
  </div>
<!--l. 903--><p class="indent" >  The program ﬁle <span 
class="ectt-1200">functionsIntExpFOC.m </span>therefore uses the function <img 
src="SolvingMicroDSOPs229x.svg" alt="𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>deﬁned
in <span 
class="ectt-1200">functions_stable.m </span>as the embodiment of equation (<a 
href="#x1-10005r28">28<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>), and constructs the
<span 
class="ectt-1200">InterpolatingFunction </span>as described above. The results are shown in Figure <a 
href="#x1-100067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>. The linear
interpolating approximation looks roughly as good (or bad) for the <span 
class="ecti-1200">marginal </span>value function as
it was for the level of the value function. However, Figure <a 
href="#x1-100078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> shows that the new consumption
function (long dashes) is a considerably better approximation of the true consumption
function (solid) than was the consumption function obtained by approximating the level of the
value function (short dashes).
<!--l. 917--><p class="indent" >  <a 
 id="PlotcTm1ABC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100078"></a>
                                                                                     
                                                                                     
<!--l. 919--><p class="noindent" > <img 
src="./Figures/PlotcTm1ABC.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 8: </span><span  
class="content"><img 
src="SolvingMicroDSOPs230x.svg" alt="cT−1(mT − 1)  " class="math";align="absmiddle"> (solid) Versus Two Methods for Constructing <img 
src="SolvingMicroDSOPs231x.svg" alt="`cT−1(mT −1)  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-100078 -->
                                                                                     
                                                                                     
  </div>
<!--l. 924--><p class="indent" >  <a 
 id="Transformation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.6  </span> <a 
 id="x1-110005.6"></a>Transformation</h4>
<!--l. 927--><p class="noindent" >Even the new-and-improved consumption function diverges notably from the true solution,
especially at lower values of <img 
src="SolvingMicroDSOPs232x.svg" alt="m  " class="math";align="absmiddle">. That is because the linear interpolation does an increasingly
poor job of capturing the nonlinearity of <img 
src="SolvingMicroDSOPs233x.svg" alt=" ′
𝔳T− 1(aT −1)  " class="math";align="absmiddle"> at lower and lower levels of
<img 
src="SolvingMicroDSOPs234x.svg" alt="a  " class="math";align="absmiddle">.
<!--l. 933--><p class="indent" >  This is where we unveil our next trick. To understand the logic, start by considering the
case where <img 
src="SolvingMicroDSOPs235x.svg" alt="ℛ  =  β = Γ  =  1
 T          T  " class="math";align="absmiddle"> and there is no uncertainty  (that is, we know for
sure that income next period will be <img 
src="SolvingMicroDSOPs236x.svg" alt="𝜃T = 1  " class="math";align="absmiddle">). The ﬁnal Euler equation is then:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs237x.svg" alt="c−ρ   =   c−ρ.                               (29)
 T−1       T
" class="math-display" ></center>
</div>
<!--l. 943--><p class="indent" >  In the case we are now considering with no uncertainty and no liquidity constraints, the
optimizing consumer does not care whether a unit of income is scheduled to be received in the
future period <img 
src="SolvingMicroDSOPs238x.svg" alt="T  " class="math";align="absmiddle"> or the current period <img 
src="SolvingMicroDSOPs239x.svg" alt="T − 1  " class="math";align="absmiddle">; there is perfect certainty that the income will
be received, so the consumer treats it as equivalent to a unit of current wealth. Total resources
therefore are comprised of two types: current market resources <img 
src="SolvingMicroDSOPs240x.svg" alt="mT −1   " class="math";align="absmiddle"> and ‘human wealth’
(the PDV of future income) of <img 
src="SolvingMicroDSOPs241x.svg" alt="𝔥T−1 = 1  " class="math";align="absmiddle"> (where we use the Gothic font to signify that this is
the expectation, as of the END of the period, of the income that will be received in future
periods; it does not include current income, which has already been incorporated into
<img 
src="SolvingMicroDSOPs242x.svg" alt="m
  T− 1   " class="math";align="absmiddle">).
<!--l. 956--><p class="indent" >  The optimal solution is to spend half of total lifetime resources in period <img 
src="SolvingMicroDSOPs243x.svg" alt="T − 1  " class="math";align="absmiddle">
and the remainder in period <img 
src="SolvingMicroDSOPs244x.svg" alt="T  " class="math";align="absmiddle">. Since total resources are known with certainty
to be <img 
src="SolvingMicroDSOPs245x.svg" alt="mT − 1 + 𝔥T −1 = mT −1 + 1  " class="math";align="absmiddle">, and since <img 
src="SolvingMicroDSOPs246x.svg" alt="v′T−1(mT −1) = u ′(cT−1)  " class="math";align="absmiddle"> this implies
that
  <table 
class="equation"><tr><td><a 
 id="x1-11002r30"></a>
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs247x.svg" alt="               (          ) −ρ
v′   (m    ) =   mT-−1 +-1-   .
 T −1   T−1          2
" class="math-display" ></center></td><td class="equation-label">(30)</td></tr></table>
<!--l. 967--><p class="nopar" >
Of course, this is a highly nonlinear function. However, if we raise both sides of (<a 
href="#x1-11002r30">30<!--tex4ht:ref: eq:vPLin --></a>) to the
power <img 
src="SolvingMicroDSOPs248x.svg" alt="(− 1 ∕ρ)  " class="math";align="absmiddle"> the result is a linear function: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs249x.svg" alt="  ′          −1∕ρ      mT −1 + 1
[vT− 1(mT − 1)]     =   ---------.                      (31)
                           2
" class="math-display" ></center>
</div>This is a speciﬁc example of a general phenomenon: A theoretical literature cited in <a 
href="#Xcarroll&kimball:concavity">Carroll
and Kimball</a> (<a 
href="#Xcarroll&kimball:concavity">1996</a>) establishes that under perfect certainty, if the period-by-period marginal
utility function is of the form <img 
src="SolvingMicroDSOPs250x.svg" alt=" −ρ
ct  " class="math";align="absmiddle">, the marginal value function will be of the form
<img 
src="SolvingMicroDSOPs251x.svg" alt="(γmt  + ζ)−ρ  " class="math";align="absmiddle"> for some constants <img 
src="SolvingMicroDSOPs252x.svg" alt="{γ, ζ} " class="math";align="absmiddle">. This means that if we were solving the perfect
foresight problem numerically, we could always calculate a numerically exact (because linear)
interpolation. To put this in intuitive terms, the problem we are facing is that the marginal
value function is highly nonlinear. But we have a compelling solution to that problem,
because the nonlinearity springs largely from the fact that we are raising something to
the power <img 
src="SolvingMicroDSOPs253x.svg" alt="−  ρ  " class="math";align="absmiddle">. In eﬀect, we can ‘unwind’ all of the nonlinearity owing to that
operation and the remaining nonlinearity will not be nearly so great. Speciﬁcally,
applying the foregoing insights to the end-of-period value function <img 
src="SolvingMicroDSOPs254x.svg" alt="𝔳
 T−1   " class="math";align="absmiddle">, we can deﬁne
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs255x.svg" alt="𝔠T−1(aT−1)  ≡   [𝔳′T −1(aT−1)]−1∕ρ                      (32)
" class="math-display" ><a 
 id="x1-11004r32"></a></center>
</div>which would be linear in the perfect foresight case. Thus, our procedure is to calculate the
                                                                                     
                                                                                     
values of <img 
src="SolvingMicroDSOPs256x.svg" alt="𝔠T− 1,i  " class="math";align="absmiddle"> at each of the <img 
src="SolvingMicroDSOPs257x.svg" alt="aT−1,i  " class="math";align="absmiddle"> gridpoints, with the idea that we will construct <img 
src="SolvingMicroDSOPs258x.svg" alt="`𝔠T− 1   " class="math";align="absmiddle">
as the interpolating function connecting these points.
<!--l. 1000--><p class="indent" >  <a 
 id="The-Self-Imposed-Natural-Borrowing-Constraint-and-the-a-Lower-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.7  </span> <a 
 id="x1-120005.7"></a>The Self-Imposed ‘Natural’ Borrowing Constraint and the <img 
src="SolvingMicroDSOPs259x.svg" alt="a
 T−1   " class="math";align="absmiddle"> Lower Bound</h4>
<!--l. 1004--><p class="noindent" >This is the appropriate moment to ask an awkward question that we have so far neglected:
How should a function like <img 
src="SolvingMicroDSOPs260x.svg" alt="`𝔠T− 1   " class="math";align="absmiddle"> be evaluated outside the range of points spanned by
<img 
src="SolvingMicroDSOPs261x.svg" alt="{aT −1,1,...,aT− 1,n} " class="math";align="absmiddle"> for which we have calculated the corresponding <img 
src="SolvingMicroDSOPs262x.svg" alt="𝔠T −1,i  " class="math";align="absmiddle"> gridpoints
used to produce our linearly interpolating approximation <img 
src="SolvingMicroDSOPs263x.svg" alt="`𝔠T− 1   " class="math";align="absmiddle"> (as described in
section <a 
href="#x1-80005.3">5.3<!--tex4ht:ref: subsec:LinInterp --></a>)?
<!--l. 1011--><p class="indent" >  The natural answer would seem to be linear extrapolation; for example, we could use
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs264x.svg" alt="`𝔠   (a    ) =   `𝔠   (a     ) + `𝔠a  (a    )(a    − a     )          (33)
 T−1  T− 1       T−1  T− 1,1    T −1  T−1,1   T− 1    T−1,1
" class="math-display" ><a 
 id="x1-12001r33"></a></center>
</div>for values of <img 
src="SolvingMicroDSOPs265x.svg" alt="a    &#x003C; a
 T−1     T−1,1   " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs266x.svg" alt="`𝔠a   (a     )
 T− 1  T−1,1  " class="math";align="absmiddle"> is the derivative of the <img 
src="SolvingMicroDSOPs267x.svg" alt="`𝔠
 T−1   " class="math";align="absmiddle"> function at
the bottommost gridpoint (see below). Unfortunately, this approach will lead us
into diﬃculties. To see why, consider what happens to the true (not approximated)
<img 
src="SolvingMicroDSOPs268x.svg" alt="𝔳T −1(aT−1)  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs269x.svg" alt="aT− 1   " class="math";align="absmiddle"> approaches the value <img 
src="SolvingMicroDSOPs270x.svg" alt="aT −1 = − 𝜃-ℛ −T1  " class="math";align="absmiddle">. From (<a 
href="#x1-10005r28">28<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>) we have
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs271x.svg" alt="                                        (    ) n∑𝜃
  lim   𝔳 ′  (a   )  =     lim   βR Γ −ρ  -1-     (a    ℛ  +  𝜃)− ρ.    (34)
aT−1↓aT−1  T−1  T−1       aT−1↓aT−1     T   n𝜃        T −1  T    i
                                               i=1
" class="math-display" ></center>
</div>
                                                                                     
                                                                                     
<!--l. 1026--><p class="indent" >  But since <img 
src="SolvingMicroDSOPs272x.svg" alt="𝜃-=  𝜃1   " class="math";align="absmiddle">, exactly at <img 
src="SolvingMicroDSOPs273x.svg" alt="aT−1 = aT −1   " class="math";align="absmiddle"> the ﬁrst term in the summation would be
<img 
src="SolvingMicroDSOPs274x.svg" alt="(− 𝜃-+ 𝜃1)−ρ = 1∕0ρ  " class="math";align="absmiddle"> which is inﬁnity. The reason is simple: <img 
src="SolvingMicroDSOPs275x.svg" alt="− aT −1   " class="math";align="absmiddle"> is the PDV, as of
<img 
src="SolvingMicroDSOPs276x.svg" alt="T −  1  " class="math";align="absmiddle">, of the minimum possible realization of income in period <img 
src="SolvingMicroDSOPs277x.svg" alt="T  " class="math";align="absmiddle"> (<img 
src="SolvingMicroDSOPs278x.svg" alt="ℛT  a-   = − 𝜃1
     T−1   " class="math";align="absmiddle">). Thus,
if the consumer borrows an amount greater than or equal to <img 
src="SolvingMicroDSOPs279x.svg" alt="𝜃ℛ −1
-- T  " class="math";align="absmiddle"> (that is, if the consumer
ends <img 
src="SolvingMicroDSOPs280x.svg" alt="T −  1  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs281x.svg" alt="             −1
aT −1 ≤ − 𝜃ℛ T  " class="math";align="absmiddle">) and then draws the worst possible income shock in
period <img 
src="SolvingMicroDSOPs282x.svg" alt="T  " class="math";align="absmiddle">, he will have to consume zero in period <img 
src="SolvingMicroDSOPs283x.svg" alt="T  " class="math";align="absmiddle"> (or a negative amount), which
yields <img 
src="SolvingMicroDSOPs284x.svg" alt="− ∞ " class="math";align="absmiddle"> utility and <img 
src="SolvingMicroDSOPs285x.svg" alt="∞ " class="math";align="absmiddle"> marginal utility (or undeﬁned utility and marginal
utility).
<!--l. 1040--><p class="indent" >  These reﬂections lead us to the conclusion that the consumer faces a ‘self-imposed’ liquidity
constraint (which results from the precautionary motive): He will never borrow an amount
greater than or equal to <img 
src="SolvingMicroDSOPs286x.svg" alt="𝜃ℛ −T1  " class="math";align="absmiddle"> (that is, assets will never reach the lower bound of
<img 
src="SolvingMicroDSOPs287x.svg" alt="aT −1 " class="math";align="absmiddle">).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs17.html#fn16x0"><sup class="textsuperscript">16</sup></a></span><a 
 id="x1-12003f16"></a> 
The constraint is ‘self-imposed’ in the sense that if the utility function were diﬀerent (say,
Constant Absolute Risk Aversion), the consumer would be willing to borrow more than <img 
src="SolvingMicroDSOPs288x.svg" alt="   −1
𝜃ℛ T  " class="math";align="absmiddle">
because a choice of zero or negative consumption in period <img 
src="SolvingMicroDSOPs289x.svg" alt="T  " class="math";align="absmiddle"> would yield some ﬁnite amount
of utility.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs18.html#fn17x0"><sup class="textsuperscript">17</sup></a></span><a 
 id="x1-12004f17"></a> 
<!--l. 1057--><p class="indent" >  This self-imposed constraint cannot be captured well when the <img 
src="SolvingMicroDSOPs290x.svg" alt="𝔳′T− 1   " class="math";align="absmiddle"> function is
approximated by a piecewise linear function like <img 
src="SolvingMicroDSOPs291x.svg" alt="`𝔳′
 T− 1   " class="math";align="absmiddle">, because a linear approximation can
never reach the correct gridpoint for <img 
src="SolvingMicroDSOPs292x.svg" alt="𝔳′   (a   ) = ∞.
 T −1 -T−1  " class="math";align="absmiddle"> To see what will happen instead, note
ﬁrst that if we are approximating <img 
src="SolvingMicroDSOPs293x.svg" alt=" ′
𝔳T−1   " class="math";align="absmiddle"> the smallest value in <span 
class="ectt-1200">aVec </span>must be greater than
<img 
src="SolvingMicroDSOPs294x.svg" alt="aT −1 " class="math";align="absmiddle"> (because the expectation for any gridpoint <img 
src="SolvingMicroDSOPs295x.svg" alt="≤ aT −1   " class="math";align="absmiddle"> is undeﬁned). Then when the
approximating <img 
src="SolvingMicroDSOPs296x.svg" alt="𝔳′T −1   " class="math";align="absmiddle"> function is evaluated at some value less than the ﬁrst element in
<span 
class="ectt-1200">aVec[1]</span>, the approximating function will linearly extrapolate the slope that characterized the
lowest segment of the piecewise linear approximation (between <span 
class="ectt-1200">aVec[1] </span>and <span 
class="ectt-1200">aVec[2]</span>), a
procedure that will return a positive ﬁnite number, even if the requested <img 
src="SolvingMicroDSOPs297x.svg" alt="aT−1   " class="math";align="absmiddle"> point is below
<img 
src="SolvingMicroDSOPs298x.svg" alt="aT −1 " class="math";align="absmiddle">. This means that the precautionary saving motive is understated, and by an
arbitrarily large amount as the level of assets approaches its true theoretical minimum
<img 
src="SolvingMicroDSOPs299x.svg" alt="a-
 T −1 " class="math";align="absmiddle">.
<!--l. 1076--><p class="indent" >  The foregoing logic demonstrates that the marginal value of saving approaches inﬁnity as
<img 
src="SolvingMicroDSOPs300x.svg" alt="                    −1
aT −1 ↓ aT −1 = − 𝜃-ℛ T  " class="math";align="absmiddle">. But this implies that <img 
src="SolvingMicroDSOPs301x.svg" alt="                           ′          −1∕ρ
limaT −1↓aT− 1 𝔠T−1(aT− 1) = (𝔳T −1(aT−1))   =  0  " class="math";align="absmiddle">;
that is, as <img 
src="SolvingMicroDSOPs302x.svg" alt="a  " class="math";align="absmiddle"> approaches its minimum possible value, the corresponding amount of <img 
src="SolvingMicroDSOPs303x.svg" alt="c  " class="math";align="absmiddle"> must
approach <span 
class="ecti-1200">its </span>minimum possible value: zero.
<!--l. 1083--><p class="indent" >  The upshot of this discussion is a realization that all we need to do is to augment each of
the <img 
src="SolvingMicroDSOPs304x.svg" alt="⃗aT− 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs305x.svg" alt="⃗cT− 1   " class="math";align="absmiddle"> vectors with an extra point so that the ﬁrst element in the list used to
produce our <span 
class="ectt-1200">InterpolatingFunction </span>is <img 
src="SolvingMicroDSOPs306x.svg" alt="{aT −1,0,cT− 1,0} = {aT −1,0.} " class="math";align="absmiddle">.
<!--l. 1088--><p class="indent" >  <a 
 id="GothVInvVSGothC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120059"></a>
                                                                                     
                                                                                     
<!--l. 1090--><p class="noindent" > <img 
src="./Figures/GothVInvVSGothC.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 9: </span><span  
class="content"><img 
src="SolvingMicroDSOPs307x.svg" alt="𝔠T−1(aT− 1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs308x.svg" alt="`𝔠T− 1(aT−1)  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-120059 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1097--><p class="indent" >  Figure <a 
href="#x1-120059">9<!--tex4ht:ref: fig:GothVInvVSGothC --></a> plots the results (generated by the program <span 
class="ectt-1200">2periodIntExpFOCInv.m</span>). The solid
line calculates the exact numerical value of <img 
src="SolvingMicroDSOPs309x.svg" alt="𝔠T−1(aT− 1)  " class="math";align="absmiddle"> while the dashed line is the linear
interpolating approximation <img 
src="SolvingMicroDSOPs310x.svg" alt="`𝔠   (a   ).
 T −1  T−1  " class="math";align="absmiddle"> This ﬁgure well illustrates the value of the
transformation: The true function is close to linear, and so the linear approximation is
almost indistinguishable from the true function except at the very lowest values of
<img 
src="SolvingMicroDSOPs311x.svg" alt="aT −1   " class="math";align="absmiddle">.
<!--l. 1110--><p class="indent" >  Figure <a 
href="#x1-1200610">10<!--tex4ht:ref: fig:GothVVSGothCInv --></a> similarly shows that when we calculate <img 
src="SolvingMicroDSOPs312x.svg" alt="``𝔳′  (a    )
 T−1  T− 1  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs313x.svg" alt="[`𝔠   (a    )]−ρ
  T−1  T− 1  " class="math";align="absmiddle"> (dashed
line) we obtain a <span 
class="ecti-1200">much </span>closer approximation to the true function <img 
src="SolvingMicroDSOPs314x.svg" alt=" ′
𝔳T− 1(aT −1)  " class="math";align="absmiddle"> (solid
line) than we did in the previous  program which did not do the transformation
(Figure <a 
href="#x1-100067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>).
<!--l. 1120--><p class="indent" >  <a 
 id="GothVVSGothCInv"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1200610"></a>
                                                                                     
                                                                                     
<!--l. 1122--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInv.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 10: </span><span  
class="content"><img 
src="SolvingMicroDSOPs315x.svg" alt="𝔳′T− 1(aT −1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs316x.svg" alt="``𝔳′T−1(aT−1)  " class="math";align="absmiddle"> Constructed Using <img 
src="SolvingMicroDSOPs317x.svg" alt="`𝔠T −1(aT−1)  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-1200610 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1129--><p class="indent" >  <a 
 id="The-Method-of-Endogenous-Gridpoints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.8  </span> <a 
 id="x1-130005.8"></a>The Method of Endogenous Gridpoints</h4>
<!--l. 1132--><p class="noindent" >Our solution procedure for <img 
src="SolvingMicroDSOPs318x.svg" alt="c
 T−1   " class="math";align="absmiddle"> still requires us, for each point in <img 
src="SolvingMicroDSOPs319x.svg" alt="⃗m
  T−1   " class="math";align="absmiddle"> (<span 
class="ectt-1200">mVect </span>in the
code), to use a numerical rootﬁnding algorithm to search for the value of <img 
src="SolvingMicroDSOPs320x.svg" alt="cT−1   " class="math";align="absmiddle"> that
solves <img 
src="SolvingMicroDSOPs321x.svg" alt=" ′          ′
u(cT− 1) = 𝔳T−1(mT −1 − cT−1)  " class="math";align="absmiddle">. Unfortunately, rootﬁnding is a notoriously
computation-intensive (that is, slow!) operation.
<!--l. 1139--><p class="indent" >  Our next trick lets us completely skip the rootﬁnding step. The method can be understood
by noting that any arbitrary value of <img 
src="SolvingMicroDSOPs322x.svg" alt="a
 T− 1,i  " class="math";align="absmiddle"> (greater than its lower bound value <img 
src="SolvingMicroDSOPs323x.svg" alt="a
-T−1   " class="math";align="absmiddle">) will
be associated with <span 
class="ecti-1200">some </span>marginal valuation as of the end of period <img 
src="SolvingMicroDSOPs324x.svg" alt="T − 1  " class="math";align="absmiddle">, and the further
observation that it is trivial to ﬁnd the value of <img 
src="SolvingMicroDSOPs325x.svg" alt="c  " class="math";align="absmiddle"> that yields the same marginal valuation,
using the ﬁrst order condition, <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs326x.svg" alt=" ′             ′
u(cT− 1,i) =   𝔳T− 1(aT −1,i)                            (35)
   cT− 1,i =   u′−1(𝔳′T−1(aT −1,i))                      (36)
                ′           −1∕ρ
          =   (𝔳T− 1(aT −1,i))                          (37)
          ≡   𝔠T−1(aT −1,i)                            (38)

          ≡   𝔠T−1,i.                                  (39)
" class="math-display" ><a 
 id="x1-13001r35"></a></center>
</div>
<!--l. 1155--><p class="indent" >  But with mutually consistent values of <img 
src="SolvingMicroDSOPs327x.svg" alt="cT−1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs328x.svg" alt="aT−1,i  " class="math";align="absmiddle"> (consistent, in the sense that
they are the unique optimal values that correspond to the solution to the problem in a
single state), we can obtain the <img 
src="SolvingMicroDSOPs329x.svg" alt="mT −1,i  " class="math";align="absmiddle"> that corresponds to both of them from
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs330x.svg" alt="mT −1,i  =  cT −1,i + aT −1,i.                        (40)
" class="math-display" ></center>
</div>
<!--l. 1162--><p class="indent" >  These <img 
src="SolvingMicroDSOPs331x.svg" alt="mT −1   " class="math";align="absmiddle"> gridpoints are “endogenous” in contrast to the usual solution method of
specifying some ex-ante grid of values of <img 
src="SolvingMicroDSOPs332x.svg" alt="mT − 1   " class="math";align="absmiddle"> and then using a rootﬁnding routine to locate
the corresponding optimal <img 
src="SolvingMicroDSOPs333x.svg" alt="cT−1   " class="math";align="absmiddle">.
<!--l. 1166--><p class="indent" >  Thus, we can generate a set of <img 
src="SolvingMicroDSOPs334x.svg" alt="m
  T−1,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs335x.svg" alt="c
T −1,i  " class="math";align="absmiddle"> pairs that can be interpolated between in
order to yield <img 
src="SolvingMicroDSOPs336x.svg" alt="`c(mT −1)  " class="math";align="absmiddle"> at virtually zero computational cost once we have the <img 
src="SolvingMicroDSOPs337x.svg" alt="⃗𝔠T− 1   " class="math";align="absmiddle"> values in
hand!<span class="footnote-mark"><a 
href="SolvingMicroDSOPs19.html#fn18x0"><sup class="textsuperscript">18</sup></a></span><a 
 id="x1-13003f18"></a> 
One might worry about whether the <img 
src="SolvingMicroDSOPs338x.svg" alt="{m, c} " class="math";align="absmiddle"> points obtained in this way will provide a good
representation of the consumption function as a whole, but in practice there are good reasons
why they work well (basically, this procedure generates a set of gridpoints that is
naturally dense right around the parts of the function with the greatest nonlinearity). <a 
 id="PlotComparecTm1AD"></a>
<div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1300411"></a>
                                                                                     
                                                                                     
<!--l. 1178--><p class="noindent" > <img 
src="./Figures/PlotComparecTm1AD.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 11: </span><span  
class="content"><img 
src="SolvingMicroDSOPs339x.svg" alt="cT− 1(mT − 1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs340x.svg" alt="`cT −1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></div><!--tex4ht:label?: x1-1300411 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1182--><p class="indent" >  Figure <a 
href="#x1-1300411">11<!--tex4ht:ref: fig:ComparecTm1AD --></a> plots the actual consumption function <img 
src="SolvingMicroDSOPs341x.svg" alt="cT−1   " class="math";align="absmiddle"> and the approximated consumption
function <img 
src="SolvingMicroDSOPs342x.svg" alt="`cT−1   " class="math";align="absmiddle"> derived by the method of endogenous grid points. Compared to the
approximate consumption functions illustrated in Figure <a 
href="#x1-100078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> <img 
src="SolvingMicroDSOPs343x.svg" alt="`c
 T −1   " class="math";align="absmiddle"> is quite close to the actual
consumption function.
<!--l. 1191--><p class="indent" >  <a 
 id="Improving-the-a-Grid"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.9  </span> <a 
 id="x1-140005.9"></a>Improving the <img 
src="SolvingMicroDSOPs344x.svg" alt="a  " class="math";align="absmiddle"> Grid</h4>
<!--l. 1194--><p class="noindent" >Thus far, we have arbitrarily used <img 
src="SolvingMicroDSOPs345x.svg" alt="a  " class="math";align="absmiddle"> gridpoints of <img 
src="SolvingMicroDSOPs346x.svg" alt="{0.,1.,2.,3.,4.} " class="math";align="absmiddle"> (augmented
in the last subsection by <img 
src="SolvingMicroDSOPs347x.svg" alt="a
-T −1   " class="math";align="absmiddle">). But it has been obvious from the ﬁgures that
the approximated <img 
src="SolvingMicroDSOPs348x.svg" alt="`𝔠T− 1   " class="math";align="absmiddle"> function tends to be farthest from its true value <img 
src="SolvingMicroDSOPs349x.svg" alt="𝔠T−1   " class="math";align="absmiddle"> at
low values of <img 
src="SolvingMicroDSOPs350x.svg" alt="a  " class="math";align="absmiddle">. Combining this with our insight that <img 
src="SolvingMicroDSOPs351x.svg" alt="aT−1   " class="math";align="absmiddle"> is a lower bound, we
are now in position to deﬁne a more deliberate method for constructing gridpoints
for <img 
src="SolvingMicroDSOPs352x.svg" alt="aT−1   " class="math";align="absmiddle"> – a method that yields values that are more densely spaced than the
uniform grid at low values of <img 
src="SolvingMicroDSOPs353x.svg" alt="a  " class="math";align="absmiddle">. A pragmatic choice that works well is to ﬁnd the
values such that (1) the last value <span 
class="ecti-1200">exceeds the lower bound </span>by the same amount
<img 
src="SolvingMicroDSOPs354x.svg" alt="¯aT −1   " class="math";align="absmiddle"> as our original maximum gridpoint (in our case, 4.); (2) we have the same
number of gridpoints as before; and (3) the <span 
class="ecti-1200">multi-exponential growth rate </span>(that is,
<img 
src="SolvingMicroDSOPs355x.svg" alt="   ...
eee   " class="math";align="absmiddle"> for some number of exponentiations <img 
src="SolvingMicroDSOPs356x.svg" alt="n 𝜃  " class="math";align="absmiddle">) from each point to the next point is
constant (instead of, as previously, imposing constancy of the absolute gap between
points).
<!--l. 1211--><p class="indent" >  <a 
 id="GothVInvVSGothCEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400112"></a>
                                                                                     
                                                                                     
<!--l. 1213--><p class="noindent" > <img 
src="./Figures/GothVInvVSGothCEEE.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 12: </span><span  
class="content"><img 
src="SolvingMicroDSOPs357x.svg" alt="𝔠T−1(aT −1)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs358x.svg" alt="`𝔠T −1(aT−1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></div><!--tex4ht:label?: x1-1400112 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1220--><p class="indent" >  <a 
 id="GothVVSGothCInvEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400213"></a>
                                                                                     
                                                                                     
<!--l. 1222--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInvEEE.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 13: </span><span  
class="content"><img 
src="SolvingMicroDSOPs359x.svg" alt="𝔳′T− 1(aT −1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs360x.svg" alt="``𝔳′T−1(aT−1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></div><!--tex4ht:label?: x1-1400213 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1228--><p class="indent" >  The results (generated by the program <span 
class="ectt-1200">2periodIntExpFOCInvEEE.m</span>) are depicted in
Figures <a 
href="#x1-1400112">12<!--tex4ht:ref: fig:GothVInvVSGothCEE --></a> and <a 
href="#x1-1400213">13<!--tex4ht:ref: fig:GothVVSGothCInvEE --></a>, which are notably closer to their respective truths than the corresponding
ﬁgures that used the original grid.
<!--l. 1234--><p class="indent" >  <a 
 id="The-Method-of-Moderation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.10  </span> <a 
 id="x1-150005.10"></a>The Method of Moderation</h4>
<!--l. 2--><p class="noindent" >Unfortunately, this endogenous gridpoints solution is not very well-behaved outside the
original range of gridpoints targeted by the solution method. (Though other common solution
methods are no better outside their own predeﬁned ranges). Figure <a 
href="#x1-1500114">14<!--tex4ht:ref: fig:ExtrapProblem --></a> demonstrates the point
by plotting the amount of precautionary saving implied by a linear extrapolation of our
approximated consumption rule (the consumption of the perfect foresight consumer
<img 
src="SolvingMicroDSOPs361x.svg" alt="¯cT− 1   " class="math";align="absmiddle"> minus our approximation to optimal consumption under uncertainty, <img 
src="SolvingMicroDSOPs362x.svg" alt="`cT− 1   " class="math";align="absmiddle">).
Although theory proves that precautionary saving is always positive, the linearly
extrapolated numerical approximation eventually predicts negative precautionary
saving (at the point in the ﬁgure where the extrapolated locus crosses the horizontal
axis).
<!--l. 16--><p class="indent" >  <a 
 id="ExtrapProblemPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500114"></a>
                                                                                     
                                                                                     
<!--l. 18--><p class="noindent" > <img 
src="./Figures/ExtrapProblemPlot.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 14:  </span><span  
class="content">For  Large  Enough  <img 
src="SolvingMicroDSOPs363x.svg" alt="mT −1   " class="math";align="absmiddle">,  Predicted  Precautionary  Saving  is  Negative
(Oops!)</span></div><!--tex4ht:label?: x1-1500114 -->
                                                                                     
                                                                                     
  </div>
<!--l. 23--><p class="indent" >  This error cannot be ﬁxed by extending the upper gridpoint; in the presence of
serious uncertainty, the consumption rule will need to be evaluated outside of <span 
class="ecti-1200">any</span>
prespeciﬁed grid (because starting from the top gridpoint, a large enough realization
of the uncertain variable will push next period’s realization of assets above that
top; a similar argument applies below the bottom gridpoint). While a judicious
extrapolation technique can prevent this problem from being fatal (for example by carefully
excluding negative precautionary saving), the problem is often dealt with using
inelegant methods whose implications for the accuracy of the solution are diﬃcult to
gauge.
<!--l. 1--><p class="indent" >  As a preliminary to our solution, deﬁne <img 
src="SolvingMicroDSOPs364x.svg" alt="𝔥t  " class="math";align="absmiddle"> as end-of-period human wealth (the present
discounted value of future labor income) for a perfect foresight version of the problem of a ‘risk
optimist:’ a consumer who believes with perfect conﬁdence that the shocks will always take the
value 1, <img 
src="SolvingMicroDSOPs365x.svg" alt="𝜃t+n = 𝔼 [𝜃] = 1 ∀ n &#x003E; 0  " class="math";align="absmiddle">. The solution to a perfect foresight problem of this kind takes the
form<span class="footnote-mark"><a 
href="SolvingMicroDSOPs20.html#fn19x0"><sup class="textsuperscript">19</sup></a></span><a 
 id="x1-15002f19"></a> 
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs368x.svg" alt="¯ct(mt)  =   (mt + 𝔥t)κt                           (41)
" class="math-display" ><a 
 id="x1-15003r41"></a></center>
</div>for a constant minimal marginal propensity to consume <img 
src="SolvingMicroDSOPs369x.svg" alt="κt  " class="math";align="absmiddle"> given below.
<!--l. 1--><p class="indent" >  We similarly deﬁne <img 
src="SolvingMicroDSOPs370x.svg" alt="𝔥t  " class="math";align="absmiddle"> as ‘minimal human wealth,’ the present discounted value
of labor income if the shocks were to take on their worst possible value in every
future period <img 
src="SolvingMicroDSOPs371x.svg" alt="𝜃t+n = 𝜃-∀ n &#x003E; 0  " class="math";align="absmiddle"> (which we deﬁne as corresponding to the beliefs of a
‘pessimist’).
<!--l. 10--><p class="indent" >  We will call a ‘realist’ the consumer who correctly perceives the true probabilities of the
future risks and optimizes accordingly.
<!--l. 12--><p class="indent" >  A ﬁrst useful point is that, for the realist, a lower bound for the level of market resources is
<img 
src="SolvingMicroDSOPs372x.svg" alt="m-  = − 𝔥
  t     -t  " class="math";align="absmiddle">, because if <img 
src="SolvingMicroDSOPs373x.svg" alt="mt  " class="math";align="absmiddle"> equalled this value then there would be a positive ﬁnite chance
(however small) of receiving <img 
src="SolvingMicroDSOPs374x.svg" alt="𝜃    = 𝜃
 t+n   --  " class="math";align="absmiddle"> in every future period, which would require the
consumer to set <img 
src="SolvingMicroDSOPs375x.svg" alt="ct  " class="math";align="absmiddle"> to zero in order to guarantee that the intertemporal budget constraint
holds (this is the multiperiod generalization of the discussion in section <a 
href="#x1-120005.7">5.7<!--tex4ht:ref: subsec:LiqConstrSelfImposed --></a> about <img 
src="SolvingMicroDSOPs376x.svg" alt="aT− 1   " class="math";align="absmiddle">).
Since consumption of zero yields negative inﬁnite utility, the solution to realist consumer’s
problem is not well deﬁned for values of <img 
src="SolvingMicroDSOPs377x.svg" alt="mt &#x003C; m-
       t  " class="math";align="absmiddle">, and the limiting value of the realist’s <img 
src="SolvingMicroDSOPs378x.svg" alt="ct  " class="math";align="absmiddle"> is
                                                                                     
                                                                                     
zero as <img 
src="SolvingMicroDSOPs379x.svg" alt="mt ↓ mt  " class="math";align="absmiddle">.
<!--l. 28--><p class="indent" >  Given this result, it will be convenient to deﬁne ‘excess’ market resources as the amount by
which actual resources exceed the lower bound, and ‘excess’ human wealth as the amount by
which mean expected human wealth exceeds guaranteed minimum human wealth:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs380x.svg" alt="                =◜−◞m◟t◝
▴mt    =  mt +   𝔥
                 -t
 ▴ 𝔥t  =  𝔥t − 𝔥t.
" class="math-display" ></center>
</div>
<!--l. 37--><p class="indent" >  We can now transparently deﬁne the optimal consumption rules for the two perfect foresight
problems, those of the ‘optimist’ and the ‘pessimist.’ The ‘pessimist’ perceives human wealth
to be equal to its minimum feasible value <img 
src="SolvingMicroDSOPs381x.svg" alt="𝔥t  " class="math";align="absmiddle"> with certainty, so consumption is given by the
perfect foresight solution <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs382x.svg" alt="c (mt)  =   (mt + 𝔥 )κ-
 t                -t  t
        =   ▴mt κt.
" class="math-display" ></center>
</div>
<!--l. 48--><p class="indent" >  The ‘optimist,’ on the other hand, pretends that there is no uncertainty about future
income, and therefore consumes <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs383x.svg" alt="¯ct(mt )  =  (mt + 𝔥t − 𝔥t + 𝔥t)κt
        =  (▴mt  + ▴ 𝔥t)κt
        =  c (m ) + ▴ 𝔥 κ .
           -t   t      t-t
" class="math-display" ></center>
</div>
<!--l. 57--><p class="indent" >  It seems obvious that the spending of the realist will be strictly greater than that of the
pessimist and strictly less than that of the optimist. Figure <a 
href="#x1-1500715">15<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptNeedHiPlot --></a> illustrates the proposition for
the consumption rule in period <img 
src="SolvingMicroDSOPs384x.svg" alt="T −  1  " class="math";align="absmiddle">.
<a 
 id="IntExpFOCInvPesReaOptNeedHiPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500715"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptNeedHiPlot.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 15: </span><span  
class="content">Moderation Illustrated: <img 
src="SolvingMicroDSOPs385x.svg" alt="cT−1 &#x003C; `cT−1 &#x003C; ¯cT− 1   " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-1500715 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2--><p class="indent" >  Proof is more diﬃcult than might be imagined, but the necessary work is done in
<a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) so we will take the proposition as a fact and proceed by manipulating the
inequality:
<div class="center" 
>
<!--l. 1--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs386x.svg" alt="  ▴m  κ  &#x003C;             c(m  +  ▴m  )            &#x003C; (▴m   + ▴ 𝔥 )κ
     t-t                t-t       t                    t     t-t
− ▴mt κt &#x003E;            − ct(mt + ▴mt )           &#x003E; − (▴mt  + ▴ 𝔥t)κt
   ▴𝔥tκt &#x003E;   ( ¯ct(mt +  ▴mt ) − ct(mt + ▴mt  ))   &#x003E; 0
               ¯ct(mt-+--▴mt-) −-ct(mt-+-▴mt--)
       1 &#x003E;                ▴ 𝔥tκ-                &#x003E; 0
             ◟--------------◝◜-t------------◞
                            ≡ˆϙt
" ></div></div>
<!--l. 1--><p class="noindent" >where the fraction in the middle of the last inequality is the ratio of actual precautionary saving
(the numerator is the diﬀerence between perfect-foresight consumption and optimal
consumption in the presence of uncertainty) to the maximum conceivable amount of
precautionary saving (the amount that would be undertaken by the pessimist who consumes
nothing out of any future income beyond the perfectly certain component).
<!--l. 1--><p class="indent" >  Deﬁning <img 
src="SolvingMicroDSOPs387x.svg" alt="μ  = log ▴m
  t         t  " class="math";align="absmiddle"> (which can range from <img 
src="SolvingMicroDSOPs388x.svg" alt="−  ∞ " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs389x.svg" alt="∞ " class="math";align="absmiddle">), the object in the middle of
the last inequality is <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs390x.svg" alt="            (          μt             μt )
ˆϙ (μ )  ≡    ¯ct(mt-+-e--)-−-ct(mt--+-e--)  ,                 (42)
  t t                   ▴𝔥tκt
" class="math-display" ><a 
 id="x1-15008r42"></a></center>
</div>and we now deﬁne <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs391x.svg" alt="               (           )
                 1 − ˆϙt(μt)
ˆχχχt(μt)  =   log   ----------                          (43)
                   ˆϙt(μt)
        =   log (1∕ˆϙt(μt) − 1 )                       (44)
" class="math-display" ><a 
 id="x1-15009r44"></a></center>
</div>
which has the virtue that it is linear in the limit as <img 
src="SolvingMicroDSOPs392x.svg" alt="μt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs393x.svg" alt="+  ∞ " class="math";align="absmiddle">.
<!--l. 3--><p class="indent" >  Given <img 
src="SolvingMicroDSOPs394x.svg" alt="ˆχχχ  " class="math";align="absmiddle">, the consumption function can be recovered from
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs395x.svg" alt="            ◜-----=◞ˆϙ◟t-----◝
            (      1     )
ˆct  =  ¯ct −   ------------ ▴ 𝔥tκt.                      (45)
              1 + exp (ˆχχχt)
" class="math-display" ><a 
 id="x1-15010r45"></a></center>
</div>
<!--l. 2--><p class="indent" >  Thus, the procedure is to calculate <img 
src="SolvingMicroDSOPs396x.svg" alt="ˆχχχt  " class="math";align="absmiddle"> at the points <img 
src="SolvingMicroDSOPs397x.svg" alt="⃗μt  " class="math";align="absmiddle"> corresponding to the log of the
<img 
src="SolvingMicroDSOPs398x.svg" alt="▴ ⃗mt  " class="math";align="absmiddle"> points deﬁned above, and then using these to construct an interpolating approximation
<img 
src="SolvingMicroDSOPs399x.svg" alt="`ˆχχχ
  t " class="math";align="absmiddle"> from which we indirectly obtain our approximated consumption rule <img 
src="SolvingMicroDSOPs400x.svg" alt="`ˆc
 t  " class="math";align="absmiddle"> by substituting
<img 
src="SolvingMicroDSOPs401x.svg" alt="`
ˆχχχt " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs402x.svg" alt="ˆχχχ  " class="math";align="absmiddle"> in equation (<a 
href="#x1-15010r45">45<!--tex4ht:ref: eq:cFuncHi --></a>).
<!--l. 8--><p class="indent" >  Because this method relies upon the fact that the problem is easy to solve if the decision
maker has unreasonable views (either in the optimistic or the pessimistic direction), and
because the correct solution is always between these immoderate extremes, we call our
solution procedure the ‘method of moderation.’
<!--l. 14--><p class="indent" >  Results are shown in Figure <a 
href="#x1-1501116">16<!--tex4ht:ref: fig:ExtrapProblemSolved --></a>; a reader with very good eyesight might be able to detect
the barest hint of a discrepancy between the Truth and the Approximation at the far
righthand edge of the ﬁgure – a stark contrast with the calamitous divergence evident in
Figure <a 
href="#x1-1500114">14<!--tex4ht:ref: fig:ExtrapProblem --></a>. <a 
 id="ExtrapProblemSolvedPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1501116"></a>
                                                                                     
                                                                                     
<!--l. 21--><p class="noindent" > <img 
src="./Figures/ExtrapProblemSolvedPlot.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 16: </span><span  
class="content">Extrapolated <img 
src="SolvingMicroDSOPs403x.svg" alt="`ˆcT−1   " class="math";align="absmiddle"> Constructed Using the Method of Moderation</span></div><!--tex4ht:label?: x1-1501116 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1447--><p class="indent" >  <a 
 id="Approximating-the-Slope-Too"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.11  </span> <a 
 id="x1-160005.11"></a>Approximating the Slope Too</h4>
<!--l. 1451--><p class="noindent" >Until now, we have calculated the level of consumption at various diﬀerent gridpoints and used
linear interpolation (either directly for <img 
src="SolvingMicroDSOPs404x.svg" alt="cT −1   " class="math";align="absmiddle"> or indirectly for, say, <img 
src="SolvingMicroDSOPs405x.svg" alt="ˆχχχT− 1   " class="math";align="absmiddle">). But the resulting
piecewise linear approximations have the unattractive feature that they are not diﬀerentiable
at the ‘kink points’ that correspond to the gridpoints where the slope of the function changes
discretely.
<!--l. 1460--><p class="indent" >  <a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) shows that the true consumption function for this problem is ‘smooth:’ It
exhibits a well-deﬁned unique marginal propensity to consume at every positive value of <img 
src="SolvingMicroDSOPs406x.svg" alt="m  " class="math";align="absmiddle">.
This suggests that we should calculate, not just the level of consumption, but also the
marginal propensity to consume (henceforth <img 
src="SolvingMicroDSOPs407x.svg" alt="κ  " class="math";align="absmiddle">) at each gridpoint, and then ﬁnd an
interpolating approximation that smoothly matches both the level and the slope at those
points.
<!--l. 1470--><p class="indent" >  This requires us to diﬀerentiate (<a 
href="#x1-15008r42">42<!--tex4ht:ref: eq:koppa --></a>) and (<a 
href="#x1-15009r44">44<!--tex4ht:ref: eq:chi --></a>), yielding <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs408x.svg" alt="                        (                  )
                               ◜--≡κκκt◞(m◟t)--◝
ˆϙμ(μt)  =  (▴ 𝔥tκ-)−1eμt( κ-−  cm(m- + e μt))                 (46)
 t               t         t    t   t
           (             )
 μ           -−ϙˆμt(μt)∕ˆϙ2t
ˆχχχt(μt)  =    1∕ ˆϙ(μ ) − 1                                    (47)
                 t  t
" class="math-display" ><a 
 id="x1-16001r46"></a></center>
</div>and (dropping arguments) with some algebra these can be combined to yield <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs409x.svg" alt="        (                         )
ˆχχχ μ =     ---κt▴mt-▴-𝔥t(κt −-κt)--- .                    (48)
  t       (¯ct − ct)(¯ct − ct − κt▴𝔥t)
                                                                                     
                                                                                     
" class="math-display" ></center>
</div>
<!--l. 1481--><p class="indent" >  To compute the vector of values of (<a 
href="#x1-16001r46">46<!--tex4ht:ref: eq:koppaPrime --></a>) corresponding to the points in <img 
src="SolvingMicroDSOPs410x.svg" alt="⃗μt  " class="math";align="absmiddle">, we need the
marginal propensities to consume (designated <img 
src="SolvingMicroDSOPs411x.svg" alt="κ  " class="math";align="absmiddle">) at each of the gridpoints, <img 
src="SolvingMicroDSOPs412x.svg" alt="cm
 t  " class="math";align="absmiddle"> (the vector of
such values is <img 
src="SolvingMicroDSOPs413x.svg" alt="⃗κt  " class="math";align="absmiddle">). These can be obtained by diﬀerentiating the Euler equation (<a 
href="#x1-4010r18">18<!--tex4ht:ref: eq:upEqbetaOp --></a>) (where
we deﬁne <img 
src="SolvingMicroDSOPs414x.svg" alt="𝔪t(a) ≡ 𝔠t(a) + a  " class="math";align="absmiddle">): <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs415x.svg" alt="u′(𝔠)  =   ˆ𝔳a(𝔪 −  𝔠)                            (49)
   t        t  t    t
" class="math-display" ></center>
</div>with respect to <img 
src="SolvingMicroDSOPs416x.svg" alt="a  " class="math";align="absmiddle">, yielding a marginal propensity to <span 
class="ecti-1200">have consumed</span> <img 
src="SolvingMicroDSOPs417x.svg" alt="𝔠a  " class="math";align="absmiddle"> at each gridpoint:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs418x.svg" alt="u′′(𝔠t)𝔠at  =   ˆ𝔳ata(𝔪t − 𝔠t)                             (50)
      a       aa           ′′
      𝔠t  =   ˆ𝔳t (𝔪t − 𝔠t)∕u  (𝔠t)                       (51)
" class="math-display" ></center>
</div>and the marginal propensity to consume at the beginning of the period is obtained from the
marginal propensity to have consumed by noting that <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs419x.svg" alt="     𝔠  =  𝔪  − a

𝔠a + 1  =  𝔪a
" class="math-display" ></center>
</div>which, together with the chain rule <img 
src="SolvingMicroDSOPs420x.svg" alt=" a    m   a
𝔠  = c  𝔪  " class="math";align="absmiddle">, yields the MPC from <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs421x.svg" alt="     =𝔪a
 m  ◜ ◞a ◟ ◝      a
c  (𝔠 + 1)  =   𝔠                                   (52)
        cm  =   𝔠a∕(1 + 𝔠a).                         (53)
" class="math-display" ><a 
 id="x1-16006r53"></a></center>
</div>
<!--l. 1511--><p class="indent" >  Designating <img 
src="SolvingMicroDSOPs422x.svg" alt="`ˆcT−1   " class="math";align="absmiddle"> as the approximated consumption rule obtained using an interpolating
polynomial approximation to <img 
src="SolvingMicroDSOPs423x.svg" alt="χχχˆ  " class="math";align="absmiddle"> that matches both the level and the ﬁrst derivative at
the gridpoints, Figure <a 
href="#x1-1600717">17<!--tex4ht:ref: fig:IntExpFOCInvPesReaOptGapPlot --></a> plots the diﬀerence between this latest approximation
and the true consumption rule for period <img 
src="SolvingMicroDSOPs424x.svg" alt="T − 1  " class="math";align="absmiddle"> up to the same large value (far
beyond the largest gridpoint) used in prior ﬁgures. Of course, at the gridpoints
the approximation will match the true function; but this ﬁgure illustrates that the
approximation is quite accurate far beyond the last gridpoint (which is the last point
at which the diﬀerence touches the horizontal axis). (We plot here the diﬀerence
between the two functions rather than the level plotted in previous ﬁgures, because in
levels the approximation error would not be detectable even to the most eagle-eyed
reader.)
<!--l. 1528--><p class="indent" >  <a 
 id="IntExpFOCInvPesReaOptGapPlot"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600717"></a>
                                                                                     
                                                                                     
<!--l. 1530--><p class="noindent" > <img 
src="./Figures/IntExpFOCInvPesReaOptGapPlot.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 17: </span><span  
class="content">Diﬀerence Between True <img 
src="SolvingMicroDSOPs425x.svg" alt="cT−1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs426x.svg" alt="`ˆcT−1   " class="math";align="absmiddle"> Is Minuscule</span></div><!--tex4ht:label?: x1-1600717 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1538--><p class="indent" >  <a 
 id="Value"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.12  </span> <a 
 id="x1-170005.12"></a>Value</h4>
<!--l. 2--><p class="noindent" >Although section <a 
href="#x1-100005.5">5.5<!--tex4ht:ref: subsec:vVsuP --></a> argued that our problem is more eﬃciently solved by constructing the
consumption rule than by approximating the value function, often it is useful to know the
value function as well as the consumption rule. Fortunately, many of the tricks used when
solving for the consumption rule have a direct analogue in approximation of the value
function.
<!--l. 9--><p class="indent" >  Consider the perfect foresight (or “optimist’s”) problem in period <img 
src="SolvingMicroDSOPs427x.svg" alt="T − 1  " class="math";align="absmiddle">: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs428x.svg" alt="¯vT−1(mT − 1)  ≡   u(cT−1) + βu (cT )
             =   u(c   ) (1 + β((β R )1∕ρ)1−ρ)
                    T−1  (        T      )
             =   u(cT−1)  1 + β(βTR )1∕ρ−1
                         (         1∕ρ  )
             =   u(cT−1)  1 + (βT R)   ∕R
             =   u(cT−1) PDVTt (c)∕cT −1
                         ◟-----◝◜-----◞
                              ≡ℂTt
" class="math-display" ></center>
</div>where <img 
src="SolvingMicroDSOPs429x.svg" alt="          T
ℂTt =  PDV t (c)  " class="math";align="absmiddle"> is the present discounted value of consumption. A similar function
can be constructed recursively for earlier periods, yielding the general expression
<a 
 id="vFuncPF"></a>
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs430x.svg" alt="                  T
¯vt(mt)  =   u(¯ct)ℂ t                                    (54)
        =   u(¯ct)κ-−t1                                   (55)
        =   u((▴m   + ▴𝔥 )κ )κ− 1                      (56)
                  t      t-t1− ρt
        =   u(▴mt  + ▴ 𝔥t)κ-t  κ−t1                      (57)
        =   u(▴m   + ▴ 𝔥)κ −ρ                          (58)
                  t     t--t
" class="math-display" ><a 
 id="x1-17002r54"></a></center>
</div>where the second line uses the fact demonstrated in <a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) that <img 
src="SolvingMicroDSOPs431x.svg" alt="ℂ =  κ−1
 t    t  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  This can be transformed as <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs432x.svg" alt="¯Λt  ≡   ((1 − ρ)¯vt)1∕(1− ρ)
            T 1∕(1−ρ)
    =   ct(ℂ t )
    =   (▴mt  + ▴𝔥t)κ−t ρ∕(1−ρ)
" class="math-display" ></center>
</div>
with derivative <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs433x.svg" alt="¯Λmt  =   (ℂTt )1∕(1−ρ)κt,
         −ρ∕(1−ρ)
    =   κt
" class="math-display" ></center>
</div>and since <img 
src="SolvingMicroDSOPs434x.svg" alt="  T
ℂ t  " class="math";align="absmiddle"> is a constant while the consumption function is linear, <img 
src="SolvingMicroDSOPs435x.svg" alt="¯Λt  " class="math";align="absmiddle"> will also be
linear.
<!--l. 9--><p class="indent" >  We apply the same transformation to the value function for the problem with uncertainty
(the “realist’s” problem) and diﬀerentiate <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs436x.svg" alt="                       1∕(1−ρ)
 ¯Λt =   ((1 − ρ)¯vt(mt ))
¯Λmt  =   ((1 − ρ)¯vt(mt ))−1+1∕(1−ρ)¯vmt (mt )
" class="math-display" ></center>
</div>and an excellent approximation to the value function can be obtained by calculating the values
of <img 
src="SolvingMicroDSOPs437x.svg" alt="¯Λ   " class="math";align="absmiddle"> at the same gridpoints used by the consumption function approximation, and
interpolating among those points.
<!--l. 18--><p class="indent" >  However, as with the consumption approximation, we can do even better if we realize that
the <img 
src="SolvingMicroDSOPs438x.svg" alt="¯Λ   " class="math";align="absmiddle"> function for the optimist’s problem is an upper bound for the <img 
src="SolvingMicroDSOPs439x.svg" alt="Λ   " class="math";align="absmiddle"> function in the
presence of uncertainty, and the value function for the pessimist is a lower bound. Analogously
to (<a 
href="#x1-15008r42">42<!--tex4ht:ref: eq:koppa --></a>), deﬁne an upper-case <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs440x.svg" alt="           (          μt            μt )
ˆϘ (μ )  =    ¯Λt(mt-+-e--) −-Λt(mt-+-e-)                    (59)
 t  t             ▴ 𝔥tκt(ℂTt )1∕(1− ρ)
" class="math-display" ><a 
 id="x1-17006r59"></a></center>
</div>with derivative (dropping arguments) <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs441x.svg" alt="ˆ μ              T 1∕(1− ρ) −1 μt  m    m
Ϙ t  =  (▴ 𝔥tκt(ℂ t )     )  e  (¯Λt − Λt )                  (60)
" class="math-display" ><a 
 id="x1-17007r60"></a></center>
</div>and an upper-case version of the <img 
src="SolvingMicroDSOPs442x.svg" alt="χχχ  " class="math";align="absmiddle"> equation in (<a 
href="#x1-15009r44">44<!--tex4ht:ref: eq:chi --></a>): <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs443x.svg" alt="              (      ˆ    )
ˆXt(μt)  =  log   1 −-Ϙt(μt)                          (61)
                  Ϙˆt (μt)
              (             )
        =  log  1∕ˆϘt(μt) − 1                         (62)
" class="math-display" ><a 
 id="x1-17008r62"></a></center>
</div>with corresponding derivative <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs444x.svg" alt="         (    μ    )
 ˆμ        −-ˆϘt∕ˆϘ2t-
X t  =     1∕ˆϘ −  1                              (63)
              t
" class="math-display" ></center>
</div>and if we approximate these objects then invert them (as above with the <img 
src="SolvingMicroDSOPs445x.svg" alt="ˆϙ  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs446x.svg" alt="ˆχχχ " class="math";align="absmiddle"> functions) we obtain a very high-quality approximation to our inverted value
function at the same points for which we have our approximated value function:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs447x.svg" alt="                  =ˆϘ
            ◜(-----◞◟t----)◝
                   1
ˆΛt =   ¯Λt −   ------------ ▴ 𝔥tκt(ℂTt )1∕(1−ρ)                (64)
              1 + exp(ˆXt)
" class="math-display" ></center>
</div>from which we obtain our approximation to the value function and its derivatives as <a 
 id="vHatFunc"></a>
<div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs448x.svg" alt="  ˆvt  =  u (ˆΛt)
 ˆvmt   =  u ′(ˆΛt)ˆΛm
 mm        ′′     m  2    ′    mm
ˆvt    =  u  (ˆΛt)(ˆΛ  ) + u (ˆΛt)ˆΛ   .
" class="math-display" ></center>
</div>
<!--l. 54--><p class="indent" >  Although a linear interpolation that matches the level of <img 
src="SolvingMicroDSOPs449x.svg" alt="Λ   " class="math";align="absmiddle"> at the gridpoints is simple, a
Hermite interpolation that matches both the level and the derivative of the <img 
src="SolvingMicroDSOPs450x.svg" alt="¯Λt  " class="math";align="absmiddle"> function at the
gridpoints has the considerable virtue that the <img 
src="SolvingMicroDSOPs451x.svg" alt="¯vt  " class="math";align="absmiddle"> derived from it numerically satisﬁes
the envelope theorem at each of the gridpoints for which the problem has been
solved.
<!--l. 68--><p class="indent" >  If we use the double-derivative calculated above to produce a higher-order Hermite
polynomial, our approximation will also match marginal propensity to consume at the
gridpoints; this would guarantee that the consumption function generated from the value
function would match both the level of consumption and the marginal propensity to consume
at the gridpoints; the numerical diﬀerences between the newly constructed consumption
function and the highly accurate one constructed earlier would be negligible within the
grid.
<!--l. 1654--><p class="indent" >  <a 
 id="Refinement-A-Tighter-Upper-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.13  </span> <a 
 id="x1-180005.13"></a>Reﬁnement: A Tighter Upper Bound</h4>
<!--l. 1--><p class="noindent" ><a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) derives an upper limit <img 
src="SolvingMicroDSOPs452x.svg" alt="κ¯t  " class="math";align="absmiddle"> for the MPC as <img 
src="SolvingMicroDSOPs453x.svg" alt="mt  " class="math";align="absmiddle"> approaches its lower bound.
Using this fact plus the strict concavity of the consumption function yields the proposition
that <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs454x.svg" alt="ct(mt + ▴mt  ) &#x003C;  ¯κt▴mt.                            (65)
" class="math-display" ></center>
</div>
                                                                                     
                                                                                     
<!--l. 9--><p class="indent" >  The solution method described above does not guarantee that approximated consumption
will respect this constraint between gridpoints, and a failure to respect the constraint can
occasionally cause computational problems in solving or simulating the model. Here,
we describe a method for constructing an approximation that always satisﬁes the
constraint.
<!--l. 1--><p class="indent" >  Deﬁning <img 
src="SolvingMicroDSOPs455x.svg" alt="  #
m t  " class="math";align="absmiddle"> as the ‘cusp’ point where the two upper bounds intersect: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs456x.svg" alt="(            )
  ▴m#  + ▴ 𝔥   κ   =  ¯κ ▴m#
     t      t  -t      t    t
               #        κt▴ 𝔥t
            ▴m t   =  (1-−-κ-)¯κ-
                           -t  t
               #      -κt𝔥t −-𝔥t
             m t   =  (1 − κt)¯κt,
" class="math-display" ></center>
</div>
we want to construct a consumption function for <img 
src="SolvingMicroDSOPs457x.svg" alt="m  ∈ (m  ,m# ]
  t   -t    t  " class="math";align="absmiddle"> that respects the tighter
upper bound:
<div class="center" 
>
<!--l. 3--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs458x.svg" alt="       ▴mt κt &#x003C;       ct(mt + ▴mt )       &#x003C; ¯κt▴mt
▴mt (¯κt − κt) &#x003E;  κ¯t▴(mt  − ct(mt + ▴mt)  )  &#x003E; 0
            1 &#x003E;      ¯κt▴mt−ct(mt+▴mt)-     &#x003E; 0.
                        ▴mt(¯κt− κt)
" ></div></div>
<!--l. 1--><p class="indent" >  Again deﬁning <img 
src="SolvingMicroDSOPs459x.svg" alt="μt =  log ▴mt  " class="math";align="absmiddle">, the object in the middle of the inequality is <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs460x.svg" alt="            ¯κt − ct(mt + eμt)e−μt
ˇϙt(μt)  ≡   ---------------------
                  ¯κt − κt
 μ          ct(mt-+-e-μt)e−μt-−-κκκmt-(mt-+-eμt)-
ˇϙt(μt)  =               ¯κt − κ             .
                              t
" class="math-display" ><a 
 id="x1-18003r66"></a></center>
</div>
<!--l. 1--><p class="indent" >  As <img 
src="SolvingMicroDSOPs461x.svg" alt="mt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs462x.svg" alt="− mt  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs463x.svg" alt="ˇϙt(μt)  " class="math";align="absmiddle"> converges to zero, while as <img 
src="SolvingMicroDSOPs464x.svg" alt="mt  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs465x.svg" alt="+ ∞ " class="math";align="absmiddle">,
<img 
src="SolvingMicroDSOPs466x.svg" alt="ˇϙt(μt)  " class="math";align="absmiddle"> approaches <img 
src="SolvingMicroDSOPs467x.svg" alt="1  " class="math";align="absmiddle">.
<!--l. 5--><p class="indent" >  As before, we can derive an approximated consumption function; call it <img 
src="SolvingMicroDSOPs468x.svg" alt="`ˇct  " class="math";align="absmiddle">. This
function will clearly do a better job approximating the consumption function for low
values of <img 
src="SolvingMicroDSOPs469x.svg" alt="mt  " class="math";align="absmiddle"> while the previous approximation will perform better for high values of
<img 
src="SolvingMicroDSOPs470x.svg" alt="mt  " class="math";align="absmiddle">.
<!--l. 10--><p class="indent" >  For middling values of <img 
src="SolvingMicroDSOPs471x.svg" alt="m  " class="math";align="absmiddle"> it is not clear which of these functions will perform better.
However, an alternative is available which performs well. Deﬁne the highest gridpoint below
<img 
src="SolvingMicroDSOPs472x.svg" alt="m#t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs473x.svg" alt="¯ˇm#t  " class="math";align="absmiddle"> and the lowest gridpoint above <img 
src="SolvingMicroDSOPs474x.svg" alt="m#t  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs475x.svg" alt="ˆm#t  " class="math";align="absmiddle">. Then there will be a unique
interpolating polynomial that matches the level and slope of the consumption function at
these two points. Call this function <img 
src="SolvingMicroDSOPs476x.svg" alt="˜ct(m )  " class="math";align="absmiddle">.
<!--l. 18--><p class="indent" >  Using indicator functions that are zero everywhere except for speciﬁed intervals,
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs477x.svg" alt="                       ¯ #
 111Lo(m )  =   1 if m ≤  ˇm t
111Mid (m )  =   1 if      ¯ˇm#t &#x003C; m  &#x003C; mˆ#t
  111  (m )  =   1 if                 mˆ# ≤  m
   Hi                             --t
" class="math-display" ></center>
</div>we can deﬁne a well-behaved approximating consumption function <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs478x.svg" alt="`ct  =   111Lo`ˇct + 111Mid`˜ct + 111Hi`ˆct.                      (66)
                                                                                     
                                                                                     
" class="math-display" ></center>
</div>
<!--l. 2--><p class="indent" >  This just says that, for each interval, we use the approximation that is most appropriate.
The function is continuous and once-diﬀerentiable everywhere, and is therefore well behaved
for computational purposes.
<!--l. 17--><p class="indent" >  We now construct an upper-bound value function implied for a consumer whose spending
behavior is consistent with the reﬁned upper-bound consumption rule.
<!--l. 20--><p class="indent" >  For <img 
src="SolvingMicroDSOPs479x.svg" alt="mt  ≥ m#
        t  " class="math";align="absmiddle">, this consumption rule is the same as before, so the constructed upper-bound
value function is also the same. However, for values <img 
src="SolvingMicroDSOPs480x.svg" alt="        #
mt  &#x003C; m t  " class="math";align="absmiddle"> matters are slightly more
complicated.
<!--l. 24--><p class="indent" >  Start with the fact that at the cusp point, <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs481x.svg" alt="v¯(m#  ) =   u(¯c (m# ))ℂT
  t  t          t  #t   t
         =   u(▴m  t ¯κt)ℂTt .
" class="math-display" ></center>
</div>
<!--l. 31--><p class="indent" >  But for <span 
class="ecti-1200">all</span> <img 
src="SolvingMicroDSOPs482x.svg" alt="mt  " class="math";align="absmiddle">, <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs483x.svg" alt="¯vt(m )  =  u (¯ct(m )) + ¯𝔳t(m  − ¯ct(m )),
" class="math-display" ></center>
</div>and we assume that for the consumer below the cusp point consumption is given by <img 
src="SolvingMicroDSOPs484x.svg" alt="¯κ▴mt  " class="math";align="absmiddle"> so
for <img 
src="SolvingMicroDSOPs485x.svg" alt="       #
mt &#x003C; m t  " class="math";align="absmiddle"> <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs486x.svg" alt="                      ¯
¯vt(m )  =   u(¯κt▴m ) + 𝔳t((1 − ¯κt)▴m  ),
" class="math-display" ></center>
</div>which is easy to compute because <img 
src="SolvingMicroDSOPs487x.svg" alt="¯𝔳t(at) = β ¯vt+1 (atℛ  + 1)  " class="math";align="absmiddle"> where <img 
src="SolvingMicroDSOPs488x.svg" alt="¯vt  " class="math";align="absmiddle"> is as deﬁned above
because a consumer who ends the current period with assets exceeding the lower bound will
not expect to be constrained next period. (Recall again that we are merely constructing an
object that is guaranteed to be an <span 
class="ecti-1200">upper bound </span>for the value that the ‘realist’ consumer will
experience.) At the gridpoints deﬁned by the solution of the consumption problem can then
construct <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs489x.svg" alt="¯Λt(m ) =   ((1 − ρ)¯vt(m ))1∕(1− ρ)
" class="math-display" ></center>
</div>and its derivatives which yields the appropriate vector for constructing <img 
src="SolvingMicroDSOPs490x.svg" alt="ˇX  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs491x.svg" alt="ˇϘ  " class="math";align="absmiddle">. The rest
of the procedure is analogous to that performed for the consumption rule and is thus omitted
for brevity.
<!--l. 1820--><p class="indent" >  <a 
 id="Extension-A-Stochastic-Interest-Factor"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.14  </span> <a 
 id="x1-190005.14"></a>Extension: A Stochastic Interest Factor</h4>
<!--l. 1824--><p class="noindent" >Thus far we have assumed that the interest factor is constant at <img 
src="SolvingMicroDSOPs492x.svg" alt="R  " class="math";align="absmiddle">. Extending the previous
derivations to allow for a perfectly forecastable time-varying interest factor <img 
src="SolvingMicroDSOPs493x.svg" alt="R
  t  " class="math";align="absmiddle"> would be
trivial. Allowing for a stochastic interest factor is less trivial.
<!--l. 1829--><p class="indent" >  The easiest case is where the interest factor is i.i.d.,
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs494x.svg" alt="                          2    2
logRt+n   ∼   𝒩 (r + ϕ − σ r∕2,σr) ∀ n &#x003E; 0                 (67)
" class="math-display" ><a 
 id="x1-19001r67"></a></center>
</div>
                                                                                     
                                                                                     
<!--l. 1837--><p class="indent" >  where <img 
src="SolvingMicroDSOPs495x.svg" alt="ϕ  " class="math";align="absmiddle"> is the risk premium and the <img 
src="SolvingMicroDSOPs496x.svg" alt="  2
σ r∕2  " class="math";align="absmiddle"> adjustment to the mean log return guarantees
that an increase in <img 
src="SolvingMicroDSOPs497x.svg" alt="σ2r  " class="math";align="absmiddle"> constitutes a mean-preserving spread in the level of the
return.
<!--l. 1840--><p class="indent" >  This case is reasonably straightforward because <a 
href="#Xmerton:restat">Merton</a> (<a 
href="#Xmerton:restat">1969</a>) and <a 
href="#Xsamuelson:portfolio">Samuelson</a> (<a 
href="#Xsamuelson:portfolio">1969</a>)
showed that for a consumer without labor income (or with perfectly forecastable
labor income) the consumption function is linear, with an inﬁnite-horizon
MPC<span class="footnote-mark"><a 
href="SolvingMicroDSOPs21.html#fn20x0"><sup class="textsuperscript">20</sup></a></span><a 
 id="x1-19002f20"></a> 
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs498x.svg" alt="          (       1−ρ )1∕ρ
κ  =  1 −  β 𝔼t[R t+1 ]                             (68)
" class="math-display" ><a 
 id="x1-19003r68"></a></center>
</div>and in this case the previous analysis applies once we substitute this MPC for the one that
characterizes the perfect foresight problem without rate-of-return risk.
<!--l. 1849--><p class="indent" >  The more realistic case where the interest factor has some serial correlation is more
complex. We consider the simplest case that captures the main features of empirical interest
rate dynamics: An AR(1) process. Thus the speciﬁcation is <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs499x.svg" alt="r    − r  =   (r − r)γ + 𝜖                           (69)
  t+1            t         t+1
" class="math-display" ></center>
</div>where <img 
src="SolvingMicroDSOPs500x.svg" alt="r  " class="math";align="absmiddle"> is the long-run mean log interest factor, <img 
src="SolvingMicroDSOPs501x.svg" alt="0 &#x003C;  γ &#x003C; 1  " class="math";align="absmiddle"> is the AR(1) serial correlation
coeﬃcient, and <img 
src="SolvingMicroDSOPs502x.svg" alt="𝜖t+1   " class="math";align="absmiddle"> is the stochastic shock.
<!--l. 1858--><p class="indent" >  The consumer’s problem in this case now has two state variables, <img 
src="SolvingMicroDSOPs503x.svg" alt="mt  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs504x.svg" alt="rt  " class="math";align="absmiddle">, and is
described by <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs505x.svg" alt="                                     1− ρ
vt(mt,rt)  =    macxt  u(ct) + 𝔼t[βt+1Γ t+1 vt+1(mt+1, rt+1)]         (70)
           s.t.

       at  =    mt − ct
 rt+1 − r  =    (rt − r)γ + 𝜖t+1

    Rt+1   =    exp(rt+1 )
    mt+1   =    (Rt+1 ∕Γ t+1) at + 𝜃t+1.
                ◟---◝◜----◞
                   ≡ℛt+1
" class="math-display" ><a 
 id="x1-19005r70"></a></center>
</div>
<!--l. 1873--><p class="indent" >  We approximate the AR(1) process by a Markov transition matrix using standard
techniques. The stochastic interest factor is allowed to take on 11 values centered around the
steady-state value <img 
src="SolvingMicroDSOPs506x.svg" alt="r  " class="math";align="absmiddle"> and chosen [how?]. Given this Markov transition matrix, <span 
class="ecti-1200">conditional </span>on
the Markov AR(1) state the consumption functions for the ‘optimist’ and the ‘pessimist’ will
still be linear, with identical MPC’s that are computed numerically. Given these MPC’s, the
(conditional) realist’s consumption function can be computed for each Markov state, and the
converged consumption rules constitute the solution contingent on the dynamics of the
stochastic interest rate process.
<!--l. 1879--><p class="indent" >  In principle, this reﬁnement should be combined with the previous one; further exposition of
this combination is omitted here because no new insights spring from the combination of the
two techniques.
<!--l. 1885--><p class="indent" >  <a 
 id="Imposing-Artificial-Borrowing-Constraints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.15  </span> <a 
 id="x1-200005.15"></a>Imposing ‘Artiﬁcial’ Borrowing Constraints</h4>
<!--l. 1888--><p class="noindent" >Optimization problems often come with additional constraints that must
be satisﬁed. Particularly common is an ‘artiﬁcial’ liquidity constraint that
prevents the consumer’s net worth from falling below some value, often
zero.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs22.html#fn21x0"><sup class="textsuperscript">21</sup></a></span><a 
 id="x1-20001f21"></a> 
The problem then becomes <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs507x.svg" alt="                                          1−ρ
vT−1(mT −1)   =   mcaTx−1  u(cT− 1) + 𝔼T −1[βΓT vT (mT )]

             s.t.
       aT−1   =   mT −1 − cT− 1
        m     =   ℛ  a    + 𝜃
          T         T T −1    T
       aT−1   ≥   0.
" class="math-display" ><a 
 id="x1-20002r71"></a></center>
</div>
<!--l. 1904--><p class="indent" >  By deﬁnition, the constraint will bind if the unconstrained consumer would choose a level of
spending that would violate the constraint. Here, that means that the constraint binds if the
<img 
src="SolvingMicroDSOPs508x.svg" alt="cT− 1   " class="math";align="absmiddle"> that satisﬁes the unconstrained FOC <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs509x.svg" alt="c−T−ρ1  =  𝔳′T −1(mT −1 − cT−1)                        (71)
" class="math-display" ><a 
 id="x1-20003r71"></a></center>
</div>is greater than <img 
src="SolvingMicroDSOPs510x.svg" alt="mT − 1   " class="math";align="absmiddle">. Call <img 
src="SolvingMicroDSOPs511x.svg" alt="`c∗T−1   " class="math";align="absmiddle"> the approximated function returning the level of <img 
src="SolvingMicroDSOPs512x.svg" alt="cT− 1   " class="math";align="absmiddle"> that
satisﬁes (<a 
href="#x1-20003r71">71<!--tex4ht:ref: eq:cUnc --></a>). Then the approximated constrained optimal consumption function will
be
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs513x.svg" alt="`c    (m    )  =  min [m    ,`c∗  (m     )].                  (72)
 T −1   T−1             T−1  T−1   T− 1
" class="math-display" ><a 
 id="x1-20004r72"></a></center>
</div>
                                                                                     
                                                                                     
<!--l. 1926--><p class="indent" >  The introduction of the constraint also introduces a sharp nonlinearity in all of the
functions at the point where the constraint begins to bind. As a result, to get solutions that
are anywhere close to numerically accurate it is useful to augment the grid of values of the
state variable to include the exact value at which the constraint ceases to bind. Fortunately,
this is easy to calculate. We know that when the constraint is binding the consumer is saving
nothing, which yields marginal value of <img 
src="SolvingMicroDSOPs514x.svg" alt="𝔳′T−1(0)  " class="math";align="absmiddle">. Further, when the constraint
is binding, <img 
src="SolvingMicroDSOPs515x.svg" alt="cT− 1 = mT −1   " class="math";align="absmiddle">. Thus, the largest value of consumption for which the
constraint is binding will be the point for which the marginal utility of consumption is
exactly equal to the (expected, discounted) marginal value of saving 0. We know this
because the marginal utility of consumption is a downward-sloping function and
so if the consumer were to consume <img 
src="SolvingMicroDSOPs516x.svg" alt="𝜖  " class="math";align="absmiddle"> more, the marginal utility of that extra
consumption would be <span 
class="ecti-1200">below </span>the (discounted, expected) marginal utility of saving, and
thus the consumer would engage in positive saving and the constraint would no
longer be binding. Thus the level of <img 
src="SolvingMicroDSOPs517x.svg" alt="mT − 1   " class="math";align="absmiddle"> at which the lconstraint stops binding
is:<span class="footnote-mark"><a 
href="SolvingMicroDSOPs23.html#fn22x0"><sup class="textsuperscript">22</sup></a></span><a 
 id="x1-20005f22"></a> 
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs518x.svg" alt="u ′(m    )  =   𝔳′  (0)
     T−1        T−1
    mT −1  =   (𝔳′T−1(0))(− 1∕ρ)
           =   𝔠   (0).                              (73)
                T−1
" class="math-display" ><a 
 id="x1-20006r73"></a></center>
</div>
<!--l. 1951--><p class="indent" >  <a 
 id="cVScCon"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2000718"></a>
                                                                                     
                                                                                     
<!--l. 1953--><p class="noindent" > <img 
src="./Figures/cVScCon.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 18: </span><span  
class="content">Constrained (solid) and Unconstrained (dashed) Consumption</span></div><!--tex4ht:label?: x1-2000718 -->
                                                                                     
                                                                                     
  </div>
<!--l. 1958--><p class="indent" >  The constrained problem is solved by <span 
class="ectt-1200">2periodIntExpFOCInvPesReaOptCon.m</span>; the
resulting consumption rule is shown in Figure <a 
href="#x1-2000718">18<!--tex4ht:ref: fig:cVScCon --></a>. For comparison purposes, the
approximate consumption rule from Figure <a 
href="#x1-2000718">18<!--tex4ht:ref: fig:cVScCon --></a> is reproduced here as the solid line. The
presence of the liquidity constraint requires three changes to the procedures outlined
above:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-20009x1">We redeﬁne <img 
src="SolvingMicroDSOPs519x.svg" alt="𝔥t  " class="math";align="absmiddle">, which now is the PDV of receiving <img 
src="SolvingMicroDSOPs520x.svg" alt="𝜃t+1 = 𝜃-  " class="math";align="absmiddle"> next period and
      <img 
src="SolvingMicroDSOPs521x.svg" alt="𝜃t+n =  0 ∀ n &#x003E; 1  " class="math";align="absmiddle"> – that is, the pessimist believes he will receive nothing beyond
      period <img 
src="SolvingMicroDSOPs522x.svg" alt="t + 1  " class="math";align="absmiddle">
      </li>
      <li 
  class="enumerate" id="x1-20011x2">We augment the end-of-period <span 
class="ectt-1200">aVec </span>with zero and with a point with a small
      positive value so that the generated <span 
class="ectt-1200">mVec </span>will the binding point <img 
src="SolvingMicroDSOPs523x.svg" alt="m#   " class="math";align="absmiddle"> and a point
      just above it (so that we can better capture the curvature around that point)
      </li>
      <li 
  class="enumerate" id="x1-20013x3">We redeﬁne the optimal consumption rule as in equation (<a 
href="#x1-20004r72">72<!--tex4ht:ref: eq:LiqCons --></a>). This ensures that
      the liquidity-constrained ‘realist’ will consume more than the redeﬁned ‘pessimist,’
      so that we will have <img 
src="SolvingMicroDSOPs524x.svg" alt="ϙ  " class="math";align="absmiddle"> still between <img 
src="SolvingMicroDSOPs525x.svg" alt="0  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs526x.svg" alt="1  " class="math";align="absmiddle"> and the ‘method of moderation’
      will proceed smoothly.</li></ol>
<!--l. 1980--><p class="indent" >  As expected, the liquidity constraint only causes a divergence between the two functions at
the point where the optimal unconstrained consumption rule runs into the 45 degree
line.
<!--l. 1985--><p class="indent" >  <a 
 id="Recursions"></a>
  <h3 class="sectionHead"><span class="titlemark">6  </span> <a 
 id="x1-210006"></a>Recursion</h3>
<!--l. 1987--><p class="noindent" ><a 
 id="Theory"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.1  </span> <a 
 id="x1-220006.1"></a>Theory</h4>
<!--l. 1989--><p class="noindent" >Before we solve for periods earlier than <img 
src="SolvingMicroDSOPs527x.svg" alt="T −  1  " class="math";align="absmiddle">, we assume for convenience that in each such
period a liquidity constraint exists of the kind discussed above, preventing <img 
src="SolvingMicroDSOPs528x.svg" alt="c  " class="math";align="absmiddle"> from exceeding
<img 
src="SolvingMicroDSOPs529x.svg" alt="m  " class="math";align="absmiddle">. This simpliﬁes things a bit because now we can always consider an <span 
class="ectt-1200">aVec </span>that starts with
zero as its smallest element.
<!--l. 1995--><p class="indent" >  Recall now equations (<a 
href="#x1-4009r17">17<!--tex4ht:ref: eq:vEndPrimetOfc --></a>) and (<a 
href="#x1-4010r18">18<!--tex4ht:ref: eq:upEqbetaOp --></a>): <div class="eqnarray">
  <center class="math-display" >
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs530x.svg" alt=" ′                −ρ  ′
𝔳t(at)  =   𝔼t[βRΓ t+1u (ct+1(ℛt+1at + 𝜃t+1))]
u′(ct)  =   𝔳′t(mt  − ct).
" class="math-display" ></center>
</div>Assuming that the problem has been solved up to period <img 
src="SolvingMicroDSOPs531x.svg" alt="t + 1  " class="math";align="absmiddle"> (and thus assuming that we
have an approximated <img 
src="SolvingMicroDSOPs532x.svg" alt="`c   (m    )
 t+1   t+1  " class="math";align="absmiddle">), our solution method essentially involves using
these two equations in succession to work back progressively from period <img 
src="SolvingMicroDSOPs533x.svg" alt="T − 1  " class="math";align="absmiddle"> to
the beginning of life. Stated generally, the method is as follows. (Here, we use the
original, rather than the “reﬁned,” method for constructing consumption functions;
the generalization of the algorithm below to use the reﬁned method presents no
diﬃculties.)
<!--l. 2009--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-22003x1">For the grid of values <img 
src="SolvingMicroDSOPs534x.svg" alt="at,i  " class="math";align="absmiddle"> in <span 
class="ectt-1200">aVec</span><img 
src="SolvingMicroDSOPs535x.svg" alt="t  " class="math";align="absmiddle">, numerically calculate the values of <img 
src="SolvingMicroDSOPs536x.svg" alt="𝔠t(at,i)  " class="math";align="absmiddle"> and
      <img 
src="SolvingMicroDSOPs537x.svg" alt=" a
𝔠t(at,i)  " class="math";align="absmiddle">,
      <div class="eqnarray">
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs538x.svg" alt="                −1∕ρ
𝔠t,i =   (𝔳′t(at,i))    ,                                           (74)
        (    [   −ρ                      −ρ])− 1∕ρ
    =    β 𝔼t R Γt+1(`ct+1(ℛt+1at,i + 𝜃t+1))         ,             (75)
𝔠a  =   − (1∕ρ)(𝔳′(a  ))− 1− 1∕ρ 𝔳′′(a ),                           (76)
 t,i              t  t,i         t  t,i
      " class="math-display" ><a 
 id="x1-22004r75"></a></center>
      </div> generating vectors of values <img 
src="SolvingMicroDSOPs539x.svg" alt="⃗𝔠t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs540x.svg" alt=" a
⃗𝔠t  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-22006x2">Construct a corresponding list of values of <img 
src="SolvingMicroDSOPs541x.svg" alt="ct,i  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs542x.svg" alt="mt,i  " class="math";align="absmiddle"> from <img 
src="SolvingMicroDSOPs543x.svg" alt="ct,i = 𝔠t,i  " class="math";align="absmiddle"> and
      <img 
src="SolvingMicroDSOPs544x.svg" alt="mt,i = ct,i + at,i  " class="math";align="absmiddle">; similarly construct a corresponding list of <img 
src="SolvingMicroDSOPs545x.svg" alt="κt,i  " class="math";align="absmiddle"> using equation
      (<a 
href="#x1-16006r53">53<!--tex4ht:ref: eq:MPCfromMPTHC --></a>).
      </li>
      <li 
  class="enumerate" id="x1-22008x3">Construct a corresponding list of <img 
src="SolvingMicroDSOPs546x.svg" alt="μt,i  " class="math";align="absmiddle">, the levels and ﬁrst derivatives of <img 
src="SolvingMicroDSOPs547x.svg" alt="ϙ
 t,i  " class="math";align="absmiddle">, and the
      levels and ﬁrst derivatives of <img 
src="SolvingMicroDSOPs548x.svg" alt="χ
  t,i  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-22010x4">Construct an interpolating approximation <img 
src="SolvingMicroDSOPs549x.svg" alt="χ`t  " class="math";align="absmiddle"> that smoothly matches both the level and
      the slope at those points.
                                                                                     
                                                                                     
      </li>
      <li 
  class="enumerate" id="x1-22012x5">If we are to approximate the value function, construct a corresponding list of values of
      <img 
src="SolvingMicroDSOPs550x.svg" alt="vt,i  " class="math";align="absmiddle">, the levels and ﬁrst derivatives of <img 
src="SolvingMicroDSOPs551x.svg" alt="Ϙt,i  " class="math";align="absmiddle">, and the levels and ﬁrst derivatives of
      <img 
src="SolvingMicroDSOPs552x.svg" alt="ˆ
Xt,i  " class="math";align="absmiddle">; and construct an interpolating approximation <img 
src="SolvingMicroDSOPs553x.svg" alt="ˆ
Xt  " class="math";align="absmiddle"> that matches those
      points.</li></ol>
<!--l. 2037--><p class="indent" >  With <img 
src="SolvingMicroDSOPs554x.svg" alt="χ`t  " class="math";align="absmiddle"> in hand, our approximate consumption function is computed directly from the
appropriate substitutions in (<a 
href="#x1-15010r45">45<!--tex4ht:ref: eq:cFuncHi --></a>) and related equations. With this consumption rule in hand,
we can continue the backwards recursion to period <img 
src="SolvingMicroDSOPs555x.svg" alt="t − 1  " class="math";align="absmiddle"> and so on back to the beginning of
life.
<!--l. 2043--><p class="indent" >  Note that this loop does not contain steps for constructing <img 
src="SolvingMicroDSOPs556x.svg" alt=" ′
ˆvt(mt )  " class="math";align="absmiddle">. This is because with
<img 
src="SolvingMicroDSOPs557x.svg" alt="`ˆct(mt)  " class="math";align="absmiddle"> in hand, we simply <span 
class="ecti-1200">deﬁne</span> <img 
src="SolvingMicroDSOPs558x.svg" alt="ˆv ′t(mt ) = u′(`ˆct(mt ))  " class="math";align="absmiddle"> so there is no need to construct
interpolating approximations - the function arises ‘free’ (or nearly so) from our constructed
<img 
src="SolvingMicroDSOPs559x.svg" alt="`ˆct(mt)  " class="math";align="absmiddle">.
<!--l. 2051--><p class="indent" >  The program <span 
class="ectt-1200">multiperiodCon.m</span><span class="footnote-mark"><a 
href="SolvingMicroDSOPs24.html#fn23x0"><sup class="textsuperscript">23</sup></a></span><a 
 id="x1-22013f23"></a> 
presents a fairly general and ﬂexible approach to solving problems of this kind. The essential
structure of the program is a loop that simply works its way back from an assumed last period
of life, using the command <span 
class="ectt-1200">AppendTo </span>to record the interpolated <img 
src="SolvingMicroDSOPs560x.svg" alt="`χt  " class="math";align="absmiddle"> functions in the earlier
time periods back from the end. For a realistic life cycle problem, it would also be necessary at
a minimum to calibrate a nonconstant path of expected income growth over the
lifetime that matches the empirical proﬁle; allowing for such a calibration is the
reason we have included the <img 
src="SolvingMicroDSOPs561x.svg" alt="{Γ }Tt  " class="math";align="absmiddle"> vector in our computational speciﬁcation of the
problem.
<!--l. 2063--><p class="indent" >  <a 
 id="Mathmatica-Background"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.2  </span> <a 
 id="x1-230006.2"></a><span 
class="ecti-1200">Mathematica</span> Background</h4>
<!--l. 2065--><p class="noindent" ><span 
class="ecti-1200">Mathematica</span> has several features that are useful in solving the multiperiod problem.
      <ul class="itemize1">
      <li class="itemize">It can treat a user-created function as an object just like a number or a character.
      </li>
      <li class="itemize"><span 
class="ecti-1200">Mathematica</span> uses the ‘list’ as its basic data structure. A <span 
class="ecti-1200">Mathematica</span> ‘list’ is a
      very powerful and ﬂexible data construct. A list of length N in <span 
class="ecti-1200">Mathematica</span> can
      hold essentially anything in each of its <img 
src="SolvingMicroDSOPs562x.svg" alt="N um  " class="math";align="absmiddle"> positions - a function, a number,
      another list, a symbolic expression, or any other object that <span 
class="ecti-1200">Mathematica</span> can
      recognize. The items at position <img 
src="SolvingMicroDSOPs563x.svg" alt="i  " class="math";align="absmiddle"> in a list named <span 
class="ectt-1200">ExampleList </span>are retrieved or
      addressed using the syntax <span 
class="ectt-1200">ExampleList[[i]]</span>.
                                                                                     
                                                                                     
      </li>
      <li class="itemize">The function <span 
class="ectt-1200">Apply[FuncName_, DataListName_] </span>takes the function whose name
      is  <span 
class="ectt-1200">FuncName </span>(for  example,  <span 
class="ectt-1200">Vt</span>)  and  the  data  in  <span 
class="ectt-1200">DataListName </span>(for  example,
      <img 
src="SolvingMicroDSOPs564x.svg" alt="{1,19} " class="math";align="absmiddle">) and returns the result that would have been returned by calling the
      function <span 
class="ectt-1200">Vt[1,19]</span>.
      </li>
      <li class="itemize">The  function  <span 
class="ectt-1200">Map[FuncToApply_,DataToApplyItTo_] </span>takes  a  list  of  possible
      arguments to the function <span 
class="ectt-1200">FuncToApply </span>and applies that function to each of the
      elements of that list sequentially. For example, <span 
class="ectt-1200">Map[Sin,{1,2,3}] </span>would return a
      list <span 
class="ectt-1200">{Sin[1],Sin[2],Sin[3]}</span>.
      </li></ul>
<!--l. 2094--><p class="indent" >  <a 
 id="Program-Structure"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.3  </span> <a 
 id="x1-240006.3"></a>Program Structure</h4>
<!--l. 2097--><p class="noindent" >After the usual initializations, the heart of the program works like this.
<!--l. 2100--><p class="indent" >  <a 
 id="Iteration"></a>
  <h5 class="subsubsectionHead"><span class="titlemark">6.3.1  </span> <a 
 id="x1-250006.3.1"></a>Iteration</h5>
<!--l. 2103--><p class="noindent" >After setting up a variable <span 
class="ectt-1200">PeriodsToSolve </span>which deﬁnes the total number of periods that the
program will solve, the program sets up a “<span 
class="ectt-1200">Do[SolveAnotherPeriod,{PeriodsToSolve}]</span>”
loop that runs the function <span 
class="ectt-1200">SolveAnotherPeriod </span>the number of times corresponding to
<span 
class="ectt-1200">PeriodsToSolve</span>. Every time <span 
class="ectt-1200">SolveAnotherPeriod </span>is run, the interpolated consumption
function for one period of life earlier is calculated. The structure of the <span 
class="ectt-1200">SolveAnotherPeriod</span>
function is as follows:
<!--l. 2115--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-25002x1">Add  various  period-t  parameters  to  their  respective  lifecycle  lists,  which  is
      accomplished by calling the <span 
class="ectt-1200">AddNewPeriodToParamLifeDates </span>function.
      </li>
      <li 
  class="enumerate" id="x1-25004x2">For each <img 
src="SolvingMicroDSOPs565x.svg" alt="at,i  " class="math";align="absmiddle"> in <span 
class="ectt-1200">aVec</span>, construct <img 
src="SolvingMicroDSOPs566x.svg" alt="𝔠   " class="math";align="absmiddle"> as follows: <div class="eqnarray">
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs567x.svg" alt="            (    [   − ρ                     − ρ])−1∕ρ
𝔠t(at,i)  =    β 𝔼t R Γt+1(`ˆct+1(ℛt+1at,i + 𝜃t+1 ))                      (77)
            (                                       ) −1∕ρ
                1 ∑n𝜃  (  −ρ                    −ρ)
        =    β n--    R  Γt+1(`ˆct+1 (ℛt+1at,i + 𝜃i))          .         (78)
                𝜃 i=1
      " class="math-display" ></center>
      </div>and similarly construct the corresponding <img 
src="SolvingMicroDSOPs568x.svg" alt=" a
𝔠t(at,i)  " class="math";align="absmiddle"> We also construct the corresponding
      <span 
class="ectt-1200">mVec</span>, <img 
src="SolvingMicroDSOPs569x.svg" alt="κ   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>, etc. by calling the <span 
class="ectt-1200">AddNewPeriodToSolvedLifeDates </span>function.
      </li>
      <li 
  class="enumerate" id="x1-25007x3">For each <img 
src="SolvingMicroDSOPs570x.svg" alt="m  " class="math";align="absmiddle"> in <span 
class="ectt-1200">mVec</span>, we can deﬁne <img 
src="SolvingMicroDSOPs571x.svg" alt="▴m   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>, ﬁnd the corresponding optimal
      consumption vector for a pessimist and an optimist, construct the <img 
src="SolvingMicroDSOPs572x.svg" alt="ϙ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs573x.svg" alt="χ  " class="math";align="absmiddle">
      vectors, and ﬁnally an interpolation function <img 
src="SolvingMicroDSOPs574x.svg" alt="χ`t  " class="math";align="absmiddle">. Similarly we can construct an
      interpolation function <img 
src="SolvingMicroDSOPs575x.svg" alt="`Xt  " class="math";align="absmiddle"> that approximates the value function. The whole
      process is done by calling the <span 
class="ectt-1200">AddNewPeriodToSolvedLifeDatesPesReaOpt</span>
      function.
      </li>
      <li 
  class="enumerate" id="x1-25009x4">Various period-<img 
src="SolvingMicroDSOPs576x.svg" alt="t  " class="math";align="absmiddle"> functions are derived from <img 
src="SolvingMicroDSOPs577x.svg" alt="`χt  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs578x.svg" alt="`
Xt  " class="math";align="absmiddle"> (in <span 
class="ectt-1200">functions_ConsNVal.m</span>).
      Note that the liquidity constraint is dealt with by comparing the unconstrained solution
      <img 
src="SolvingMicroDSOPs579x.svg" alt="c   " class="math";align="absmiddle"><span 
class="ectt-1200">From</span><img 
src="SolvingMicroDSOPs580x.svg" alt="χ   " class="math";align="absmiddle"> with the 45 degree line.</li></ol>
<!--l. 2145--><p class="indent" >  <a 
 id="Results"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.4  </span> <a 
 id="x1-260006.4"></a>Results</h4>
<!--l. 2148--><p class="noindent" >As written, the program creates <img 
src="SolvingMicroDSOPs581x.svg" alt="`χ (μ )
  t t   " class="math";align="absmiddle"> functions from which the relevant <img 
src="SolvingMicroDSOPs582x.svg" alt="`c (m  )
 t   t  " class="math";align="absmiddle"> functions
are recovered in any period for any value of <img 
src="SolvingMicroDSOPs583x.svg" alt="m  " class="math";align="absmiddle">.
<!--l. 2152--><p class="indent" >  <a 
 id="PlotCFuncsConverge"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2600119"></a>
                                                                                     
                                                                                     
<!--l. 2154--><p class="noindent" > <img 
src="./Figures/PlotCFuncsConverge.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 19: </span><span  
class="content">Converging <img 
src="SolvingMicroDSOPs584x.svg" alt="`cT−n(m )  " class="math";align="absmiddle"> Functions as <img 
src="SolvingMicroDSOPs585x.svg" alt="n  " class="math";align="absmiddle"> Increases</span></div><!--tex4ht:label?: x1-2600119 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2160--><p class="indent" >  As an illustration, Figure <a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a> shows <img 
src="SolvingMicroDSOPs586x.svg" alt="`cT −n(m )  " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs587x.svg" alt="n =  {20,15,10, 5,1} " class="math";align="absmiddle">. At least one
feature of this ﬁgure is encouraging: the consumption functions converge as the
horizon extends, something that <a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) shows must be true under certain
parametric conditions that are satisﬁed by the baseline parameter values being used
here.
<!--l. 2680--><p class="indent" >  <a 
 id="Multiple-Control-Variables"></a>
  <h3 class="sectionHead"><span class="titlemark">7  </span> <a 
 id="x1-270007"></a>Multiple Control Variables</h3>
<!--l. 2683--><p class="noindent" >We now consider how to solve problems with multiple control variables. (To reduce notational
complexity, in this section we set <img 
src="SolvingMicroDSOPs588x.svg" alt="Γ t = 1 ∀ t  " class="math";align="absmiddle">.)
<!--l. 2686--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.1  </span> <a 
 id="x1-280007.1"></a>Theory</h4>
<!--l. 2687--><p class="noindent" >The new control variable that the consumer can now choose is the portion of the portfolio to
invest in risky assets. Designating the gross return on the risky asset as <img 
src="SolvingMicroDSOPs589x.svg" alt="Rt+1   " class="math";align="absmiddle">, and using <img 
src="SolvingMicroDSOPs590x.svg" alt="ςt  " class="math";align="absmiddle">
to represent the proportion of the portfolio invested in this asset between <img 
src="SolvingMicroDSOPs591x.svg" alt="t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs592x.svg" alt="t + 1  " class="math";align="absmiddle">
(restricted here, as often in the literature, to values between 0 and 1, corresponding
to an assumption that the consumer cannot be ‘net short’ and cannot issue net
equity), the overall return on the consumer’s portfolio between <img 
src="SolvingMicroDSOPs593x.svg" alt="t  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs594x.svg" alt="t + 1  " class="math";align="absmiddle"> will
be:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs595x.svg" alt="Rt+1  =   R(1 − ςt) + Rt+1 ςt                        (79)

      =   R + (Rt+1 − R )ςt                          (80)
" class="math-display" ><a 
 id="x1-28001r79"></a><a 
 id="x1-28001r80"></a></center>
</div> and the maximization problem is
<div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs596x.svg" alt="vt(mt )  =   {mcat,xςt}  u(ct) + β 𝔼t[vt+1(mt+1)]

        s.t.
  Rt+1   =   R +  (Rt+1  − R)ςt
  m      =   (m  −  c)R    + 𝜃
    t+1          t    t  t+1    t+1
   0 ≤   ςt  ≤  1,
" class="math-display" ><a 
 id="x1-28002r81"></a></center>
</div> or <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs597x.svg" alt="v (m )   =   max    u(c) + 𝔼 [βv   ((m  − c )R    + 𝜃   )]
 t   t       {ct,ςt}     t    t   t+1    t   t  t+1    t+1
        s.t.

   0 ≤   ςt  ≤ 1.
" class="math-display" ></center>
</div>The ﬁrst order condition with respect to <img 
src="SolvingMicroDSOPs598x.svg" alt="ct  " class="math";align="absmiddle"> is almost identical to that in the single-control
problem, equation (<a 
href="#x1-4001r10">10<!--tex4ht:ref: eq:upceqEvtp1 --></a>), with the only diﬀerence being that the nonstochastic interest factor
<img 
src="SolvingMicroDSOPs599x.svg" alt="R  " class="math";align="absmiddle"> is now replaced by <img 
src="SolvingMicroDSOPs600x.svg" alt="Rt+1   " class="math";align="absmiddle">,
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs601x.svg" alt=" ′                   ′
u (ct)  =   β 𝔼t [Rt+1v t+1 (mt+1 )],                     (81)
" class="math-display" ><a 
 id="x1-28004r81"></a></center>
</div> and the Envelope theorem derivation remains the same, yielding the Euler equation for
consumption
                                                                                     
                                                                                     
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs602x.svg" alt="u′(c )  =  𝔼  [βR    u′(c  )].                        (82)
   t        t   t+1    t+1
" class="math-display" ><a 
 id="x1-28005r82"></a></center>
</div>
<!--l. 2741--><p class="indent" >  The ﬁrst order condition with respect to the risky portfolio share is
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs603x.svg" alt="0  =   𝔼 [v′  (m    )(R    − R )a]
        t  t+1′  t+1    t+1       t
   =   at𝔼t [u (ct+1(mt+1 )) (Rt+1 − R)].                   (83)
" class="math-display" ><a 
 id="x1-28006r83"></a></center>
</div>
<!--l. 2750--><p class="indent" >  As before, it will be useful to deﬁne <img 
src="SolvingMicroDSOPs604x.svg" alt="𝔳t  " class="math";align="absmiddle"> as a function that yields the expected <img 
src="SolvingMicroDSOPs605x.svg" alt="t + 1  " class="math";align="absmiddle"> value
of ending period <img 
src="SolvingMicroDSOPs606x.svg" alt="t  " class="math";align="absmiddle"> in a given state. However, now that there are two control variables, the
expectation must be deﬁned as a function of the chosen values of both of those variables,
because expected end-of-period value will depend not just on how much the agent saves, but
also on how the saved assets are allocated between the risky and riskless assets. Thus we
deﬁne <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs607x.svg" alt="𝔳t(at,ςt)  =   𝔼t[βvt+1(mt+1)]
" class="math-display" ></center>
</div>which has derivatives <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs608x.svg" alt=" a               m
𝔳t  =   𝔼t[βRt+1v t+1(mt+1 )]
𝔳ςt  =   𝔼t[β (Rt+1 − R )vmt+1(mt+1 )]at
" class="math-display" ></center>
</div>implying that the ﬁrst order conditions (<a 
href="#x1-28005r82">82<!--tex4ht:ref: eq:EulercRiskyR --></a>) and (<a 
href="#x1-28006r83">83<!--tex4ht:ref: eq:FOCw --></a>) can be rewritten <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs609x.svg" alt="  ′         a
u (ct)  =  𝔳t(mt −  ct,ςt)                          (84)
     0  =  𝔳ςt(at,ςt).                               (85)
" class="math-display" ></center>
</div>
<!--l. 2772--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">7.2  </span> <a 
 id="x1-290007.2"></a>Application</h4>
<!--l. 2774--><p class="noindent" >Our ﬁrst step is to specify the stochastic process for <img 
src="SolvingMicroDSOPs610x.svg" alt="Rt+1   " class="math";align="absmiddle">. We follow the common practice of
assuming that returns are lognormally distributed, <img 
src="SolvingMicroDSOPs611x.svg" alt="                     2    2
log R ∼ 𝒩  (ϕ + r − σϕ ∕2,σϕ)  " class="math";align="absmiddle">
where <img 
src="SolvingMicroDSOPs612x.svg" alt="ϕ  " class="math";align="absmiddle"> is the equity premium over the returns <img 
src="SolvingMicroDSOPs613x.svg" alt="r  " class="math";align="absmiddle"> available on the riskless
asset.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs25.html#fn24x0"><sup class="textsuperscript">24</sup></a></span><a 
 id="x1-29001f24"></a> 
<!--l. 2780--><p class="indent" >  As with labor income uncertainty, it is necessary to discretize the rate-of-return risk in order
to have a problem that is soluble in a reasonable amount of time. We follow the same
procedure as for labor income uncertainty, generating a set of <img 
src="SolvingMicroDSOPs616x.svg" alt="nr  " class="math";align="absmiddle"> equiprobable shocks to the
rate of return; in a slight abuse of notation, we will designate the portfolio-weighted return
(contingent on the chosen portfolio share in equity, and potentially contingent on any other
aspect of the consumer’s problem) simply as <img 
src="SolvingMicroDSOPs617x.svg" alt="Ri,j  " class="math";align="absmiddle"> (where dependence on <img 
src="SolvingMicroDSOPs618x.svg" alt="i  " class="math";align="absmiddle"> is allowed to
permit the possibility of nonzero correlation between the return on the risky asset and the
shock to labor income (for example, in recessions the stock market falls and labor income also
declines).
                                                                                     
                                                                                     
<!--l. 2792--><p class="indent" >  The direct expressions for the derivatives of <img 
src="SolvingMicroDSOPs619x.svg" alt="𝔳t  " class="math";align="absmiddle"> are <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs620x.svg" alt="               (   1  ) ∑n𝜃 n∑r                      −ρ
𝔳at(at,ςt)  =   β  -----         Ri,j (ct+1(Ri,jat + 𝜃i))                (86)
                 nrn 𝜃  i=1 j=1
               (      ) ∑n𝜃 n∑r
𝔳ς(at,ςt)  =   β  --1--         (Ri,j − R )(ct+1(Ri,jat + 𝜃i))−ρ .      (87)
 t               nrn 𝜃  i=1 j=1
" class="math-display" ></center>
</div>
<!--l. 2798--><p class="indent" >  Writing these equations out explicitly makes a problem very apparent: For every diﬀerent
combination of <img 
src="SolvingMicroDSOPs621x.svg" alt="{at,ςt} " class="math";align="absmiddle"> that the routine wishes to consider, it must perform two
double-summations of <img 
src="SolvingMicroDSOPs622x.svg" alt="nr × n  " class="math";align="absmiddle"> terms. Once again, there is an ineﬃciency if it must perform
these same calculations many times for the same or nearby values of <img 
src="SolvingMicroDSOPs623x.svg" alt="{at,ςt} " class="math";align="absmiddle">, and
again the solution is to construct an approximation to the derivatives of the <img 
src="SolvingMicroDSOPs624x.svg" alt="𝔳  " class="math";align="absmiddle">
function.
<!--l. 2807--><p class="indent" >  Details of the construction of the interpolating approximation are given below; assume for
the moment that we have the approximations <img 
src="SolvingMicroDSOPs625x.svg" alt="ˆ𝔳at  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs626x.svg" alt="ˆ𝔳ςt  " class="math";align="absmiddle"> in hand and we want to proceed.
As noted above, nonlinear equation solvers (including those built into <span 
class="ecti-1200">Mathematica</span>) can ﬁnd
the solution to a set of simultaneous equations. Thus we could ask <span 
class="ecti-1200">Mathematica</span> to solve
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs627x.svg" alt="c− ρ  =  ˆ𝔳a(mt −  ct,ςt)                           (88)
 t        tς
   0  =  ˆ𝔳t(mt − ct,ςt)                           (89)
" class="math-display" ><a 
 id="x1-29003r88"></a><a 
 id="x1-29003r89"></a></center>
</div>simultaneously for <img 
src="SolvingMicroDSOPs628x.svg" alt="c  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs629x.svg" alt="ς  " class="math";align="absmiddle"> at the set of potential <img 
src="SolvingMicroDSOPs630x.svg" alt="mt  " class="math";align="absmiddle"> values deﬁned in <span 
class="ectt-1200">mVec</span>. However,
multidimensional constrained maximization problems are diﬃcult and sometimes quite slow to
solve. There is a better way. Deﬁne the problem <div class="eqnarray">
                                                                                     
                                                                                     
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs631x.svg" alt="˜𝔳t(at)  =    maςxt   𝔳t(at,ςt)                         (90)
        s.t.

  0 ≤    ςt   ≤ 1                                    (91)
" class="math-display" ></center>
</div>where the typographical diﬀerence between <img 
src="SolvingMicroDSOPs632x.svg" alt="˜𝔳  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs633x.svg" alt="𝔳  " class="math";align="absmiddle"> indicates that this is the <img 
src="SolvingMicroDSOPs634x.svg" alt="𝔳  " class="math";align="absmiddle"> that has been
optimized with respect to all of the arguments other than the one still present (<img 
src="SolvingMicroDSOPs635x.svg" alt="at  " class="math";align="absmiddle">). We solve this
problem for the set of gridpoints in <span 
class="ectt-1200">aVec </span>and use the results to construct the interpolating function
<img 
src="SolvingMicroDSOPs636x.svg" alt="`˜𝔳a(a )
 t  t  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs26.html#fn25x0"><sup class="textsuperscript">25</sup></a></span><a 
 id="x1-29005f25"></a> 
With this function in hand, we can use the ﬁrst order condition from the single-control
problem <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs639x.svg" alt="c−ρ  =  `˜𝔳a (m   − c)
 t        t  t    t
" class="math-display" ></center>
</div>to solve for the optimal level of consumption as a function of <img 
src="SolvingMicroDSOPs640x.svg" alt="m
  t  " class="math";align="absmiddle">. Thus we have transformed
the multidimensional optimization problem into a sequence of two simple optimization
problems for which solutions are much easier and more reliable.
<!--l. 2849--><p class="indent" >  Note the parallel between this trick and the fundamental insight of dynamic programming:
Dynamic programming techniques transform a multi-period (or inﬁnite-period) optimization
problem into a sequence of two-period optimization problems which are individually much
easier to solve; we have done the same thing here, but with multiple dimensions of controls
rather than multiple periods.
<!--l. 2856--><p class="indent" >  <a 
 id="Implementation"></a>
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">7.3  </span> <a 
 id="x1-300007.3"></a>Implementation</h4>
<!--l. 2859--><p class="noindent" >The program which solves the constrained problem with multiple control variables is
<span 
class="ectt-1200">multicontrolCon.m</span>.
<!--l. 2862--><p class="indent" >  Some of the functions deﬁned in <span 
class="ectt-1200">multicontrolCon.m </span>correspond to the derivatives of
<img 
src="SolvingMicroDSOPs641x.svg" alt="𝔳t(at,ςt)  " class="math";align="absmiddle">.
<!--l. 2871--><p class="indent" >  The ﬁrst function deﬁnition that does not resemble anything in <span 
class="ectt-1200">multiperiod.m </span>is
<img 
src="SolvingMicroDSOPs642x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>. This function, for its input value of <img 
src="SolvingMicroDSOPs643x.svg" alt="at  " class="math";align="absmiddle">, calculates the value of the portfolio
share <img 
src="SolvingMicroDSOPs644x.svg" alt="ςt  " class="math";align="absmiddle"> which satisﬁes the ﬁrst order condition (<a 
href="#x1-29003r89">89<!--tex4ht:ref: eq:FOCwrtw --></a>), tests whether the optimal portfolio
share would violate the constraints, and if so resets the portfolio share to the constrained
optimum. The function returns the optimal value of the portfolio share itself, <img 
src="SolvingMicroDSOPs645x.svg" alt="ς∗t  " class="math";align="absmiddle">, from which
the functions <img 
src="SolvingMicroDSOPs646x.svg" alt="¯𝔳at(at)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs647x.svg" alt="ˆςt(at)  " class="math";align="absmiddle"> will be constructed.
<!--l. 2882--><p class="indent" >  As <img 
src="SolvingMicroDSOPs648x.svg" alt="ˆςt(at)  " class="math";align="absmiddle"> can be constructed by <img 
src="SolvingMicroDSOPs649x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>, <img 
src="SolvingMicroDSOPs650x.svg" alt="¯𝔳a (at)
  t  " class="math";align="absmiddle"> is constructed by another newly
deﬁned function <img 
src="SolvingMicroDSOPs651x.svg" alt="𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">aOpt[at_]</span>, where the naming convention is obviously that ‘Opt’ stands
for ‘Optimized.’ With <img 
src="SolvingMicroDSOPs652x.svg" alt=" a
¯𝔳t(at)  " class="math";align="absmiddle"> in hand (as well as the appropriately redeﬁned <img 
src="SolvingMicroDSOPs653x.svg" alt="¯𝔳t(at)  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs654x.svg" alt="¯𝔳ata(at)  " class="math";align="absmiddle">) the analysis is essentially identical to that for the standard multiperiod problem
with a single control variable.
<!--l. 2892--><p class="indent" >  The structure of the program in detail is as follows. First, perform  the usual
initializations. Then initialize <img 
src="SolvingMicroDSOPs655x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec </span>and the other variables speciﬁc to the multiple control
problem.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs27.html#fn26x0"><sup class="textsuperscript">26</sup></a></span><a 
 id="x1-30001f26"></a> 
In particular, there are now three kinds of functions: those with both <img 
src="SolvingMicroDSOPs656x.svg" alt="at  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs657x.svg" alt="ςt  " class="math";align="absmiddle"> as
arguments, those with just <img 
src="SolvingMicroDSOPs658x.svg" alt="at  " class="math";align="absmiddle">, and those with <img 
src="SolvingMicroDSOPs659x.svg" alt="mt  " class="math";align="absmiddle">.
<!--l. 2911--><p class="indent" >  Once the setup is complete, the heart of the program is the following.
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-30003x1">Construct <img 
src="SolvingMicroDSOPs660x.svg" alt="𝔳ςt(at,ςt)  " class="math";align="absmiddle"> using the usual calculation over the tensor deﬁned by the
      combinations of the elements of <span 
class="ectt-1200">aVec </span>and <img 
src="SolvingMicroDSOPs661x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>.
      </li>
      <li 
  class="enumerate" id="x1-30005x2">For any level of saving <span 
class="ectt-1200">at</span>, the function <img 
src="SolvingMicroDSOPs662x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_] </span>performs a rootﬁnding
      operation<span class="footnote-mark"><a 
href="SolvingMicroDSOPs28.html#fn27x0"><sup class="textsuperscript">27</sup></a></span><a 
 id="x1-30006f27"></a> 
      <div class="eqnarray">
                                                                                     
                                                                                     
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs666x.svg" alt="  0   =   𝔳ςt(at,ςt)                              (92)

     s.t.
0 ≤   ςt  ≤  1                                  (93)
      " class="math-display" ></center>
      </div>and generates the corresponding optimal portfolio share <img 
src="SolvingMicroDSOPs667x.svg" alt="ς∗t  " class="math";align="absmiddle">.
      </li>
      <li 
  class="enumerate" id="x1-30009x3">Construct the function <img 
src="SolvingMicroDSOPs668x.svg" alt="˜𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span><div class="eqnarray">
      <center class="math-display" >
      <img 
src="SolvingMicroDSOPs669x.svg" alt="˜𝔳a(at) ≡ 𝔳a(at,ς∗(at))                              (94)
 t        t    t
      " class="math-display" ></center>
      </div>where <img 
src="SolvingMicroDSOPs670x.svg" alt="ς∗(at)
 t  " class="math";align="absmiddle"> is computed by <img 
src="SolvingMicroDSOPs671x.svg" alt="ς   " class="math";align="absmiddle"><span 
class="ectt-1200">Raw[at_]</span>.
      </li>
      <li 
  class="enumerate" id="x1-30012x4">Using <img 
src="SolvingMicroDSOPs672x.svg" alt="˜a
𝔳t(at) ≡ " class="math";align="absmiddle"><img 
src="SolvingMicroDSOPs673x.svg" alt="˜
𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>and the redeﬁned <img 
src="SolvingMicroDSOPs674x.svg" alt="˜
𝔳t(at)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs675x.svg" alt="˜aa
𝔳t (at)  " class="math";align="absmiddle"> (in place of
      <img 
src="SolvingMicroDSOPs676x.svg" alt=" a
𝔳t(at) ≡ " class="math";align="absmiddle"> <img 
src="SolvingMicroDSOPs677x.svg" alt="𝔳   " class="math";align="absmiddle"><span 
class="ectt-1200">a[at_] </span>in <span 
class="ectt-1200">multiperiod.m</span>), follow the same procedures as in
      <span 
class="ectt-1200">multiperiod.m </span>to generate <img 
src="SolvingMicroDSOPs678x.svg" alt="`ct(m )  " class="math";align="absmiddle">.
      </li></ol>
<!--l. 2951--><p class="indent" >   
  <h4 class="subsectionHead"><span class="titlemark">7.4  </span> <a 
 id="x1-310007.4"></a>Results</h4>
<!--l. 2954--><p class="noindent" >Figure <a 
href="#x1-3100120">20<!--tex4ht:ref: fig:PlotctMultContr --></a> plots the ﬁrst-period consumption function generated by the program; qualitatively
it does not look much diﬀerent from the consumption functions generated by the program
without portfolio choice. Figure <a 
href="#x1-3100221">21<!--tex4ht:ref: fig:PlotRiskySharetOfat --></a> plots the optimal portfolio share as a function of the level
of assets. This ﬁgure exhibits several interesting features. First, even with a coeﬃcient of
relative risk aversion of 6, an equity premium of only 4 percent, and an annual standard
deviation in equity returns of 15 percent, the optimal choice is for the agent to invest
                                                                                     
                                                                                     
a proportion 1 (100 percent) of the portfolio in stocks (instead of the safe bank
account with riskless return <img 
src="SolvingMicroDSOPs679x.svg" alt="R  " class="math";align="absmiddle">) is at values of <img 
src="SolvingMicroDSOPs680x.svg" alt="at  " class="math";align="absmiddle"> less than about 2. Second, the
proportion of the portfolio kept in stocks is <span 
class="ecti-1200">declining </span>in the level of wealth - i.e., the poor
should hold all of their meager assets in stocks, while the rich should be cautious,
holding more of their wealth in safe bank deposits and less in stocks. This seemingly
bizarre (and highly counterfactual) prediction reﬂects the nature of the risks the
consumer faces. Those consumers who are poor in measured ﬁnancial wealth are
likely to derive a high proportion of future consumption from their labor income.
Since by assumption labor income risk is uncorrelated with rate-of-return risk, the
covariance between their future consumption and future stock returns is relatively
low. By contrast, persons with relatively large wealth will be paying for a large
proportion of future consumption out of that wealth, and hence if they invest too much
of it in stocks their consumption will have a high covariance with stock returns.
Consequently, they reduce that correlation by holding some of their wealth in the riskless
form.
<!--l. 2982--><p class="indent" >  <a 
 id="PlotctMultContr"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100120"></a>
                                                                                     
                                                                                     
<!--l. 2984--><p class="noindent" > <img 
src="./Figures/PlotctMultContr.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 20: </span><span  
class="content"><img 
src="SolvingMicroDSOPs681x.svg" alt="c(m1 )  " class="math";align="absmiddle"> With Portfolio Choice</span></div><!--tex4ht:label?: x1-3100120 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2989--><p class="indent" >  <a 
 id="PlotRiskySharetOfat"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3100221"></a>
                                                                                     
                                                                                     
<!--l. 2991--><p class="noindent" > <img 
src="./Figures/PlotRiskySharetOfat.png" alt="pict"  
 width="578.15999pt" >
<br /> <div class="caption" 
><span class="id">Figure 21: </span><span  
class="content">Portfolio Share in Risky Assets in First Period <img 
src="SolvingMicroDSOPs682x.svg" alt="ς(a )  " class="math";align="absmiddle"></span></div><!--tex4ht:label?: x1-3100221 -->
                                                                                     
                                                                                     
  </div>
<!--l. 2996--><p class="indent" >  <a 
 id="The-Infinite-Horizon"></a>
  <h3 class="sectionHead"><span class="titlemark">8  </span> <a 
 id="x1-320008"></a>The-Inﬁnite-Horizon</h3>
<!--l. 2999--><p class="noindent" >All of the solution methods presented so far have involved period-by-period iteration from an
assumed last period of life, as is appropriate for life cycle problems. However, if the parameter
values for the problem satisfy certain conditions (detailed in <a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>)), the
consumption rules (and the rest of the problem) will converge to a ﬁxed rule as the
horizon (remaining lifetime) gets large, as illustrated in Figure <a 
href="#x1-2600119">19<!--tex4ht:ref: fig:PlotCFuncsConverge --></a>. Furthermore,
Deaton (<a 
href="#XdeatonLiqConstr">1991</a>), Carroll (<a 
href="#Xcarroll:brookings">1992</a>; <a 
href="#XcarrollBSLCPIH">1997</a>) and others have argued that the ‘buﬀer-stock’ saving
behavior that emerges under some further restrictions on parameter values is a good
approximation of the behavior of typical consumers over much of the lifetime. Methods for
ﬁnding the converged functions are therefore of interest, and are dealt with in this
section.
<!--l. 3015--><p class="indent" >  Of course, the simplest such method is to solve the problem as speciﬁed above for a large
number of periods. This is feasible, but there are much faster methods.
<!--l. 3019--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">8.1  </span> <a 
 id="x1-330008.1"></a>Convergence</h4>
<!--l. 3021--><p class="noindent" >In solving an inﬁnite-horizon problem, it is necessary to have some metric that determines
when to stop because a solution that is ‘good enough’ has been found.
<!--l. 3025--><p class="indent" >  A natural metric is deﬁned by the unique ‘target’ level of wealth that <a 
href="#XBufferStockTheory">Carroll</a> (<a 
href="#XBufferStockTheory">2020</a>) proves
will exist in problems of this kind: The <img 
src="SolvingMicroDSOPs683x.svg" alt="mˇ  " class="math";align="absmiddle"> such that
  <table 
class="equation"><tr><td><a 
 id="x1-33001r95"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs684x.svg" alt="𝔼t [mt+1 ∕mt ] = 1 if mt = ˇm
" class="math-display" ></center></td><td class="equation-label">(95)</td></tr></table>
<!--l. 3029--><p class="nopar" >
where the <img 
src="SolvingMicroDSOPs685x.svg" alt="∨ " class="math";align="absmiddle"> accent is meant to signify that this is the value that other <img 
src="SolvingMicroDSOPs686x.svg" alt="m  " class="math";align="absmiddle">’s ‘point
to.’
                                                                                     
                                                                                     
<!--l. 3033--><p class="indent" >  Given a consumption rule <img 
src="SolvingMicroDSOPs687x.svg" alt="c(m )  " class="math";align="absmiddle"> it is straightforward to ﬁnd the corresponding <img 
src="SolvingMicroDSOPs688x.svg" alt="ˇm  " class="math";align="absmiddle">. So for
our problem, a solution is declared to have converged if the following criterion is met:
<img 
src="SolvingMicroDSOPs689x.svg" alt="|mˇt+1 −  ˇmt| &#x003C; 𝜖  " class="math";align="absmiddle">, where <img 
src="SolvingMicroDSOPs690x.svg" alt="𝜖  " class="math";align="absmiddle"> is a very small number and measures our degree of convergence
tolerance.
<!--l. 3039--><p class="indent" >  Similar criteria can obviously be speciﬁed for other problems. However, it is always wise to
plot successive function diﬀerences and to experiment a bit with convergence criteria to verify
that the function has converged for all practical purposes.
<!--l. 3096--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">8.2  </span> <a 
 id="x1-340008.2"></a>Coarse then Fine <img 
src="SolvingMicroDSOPs691x.svg" alt="𝜃   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span></h4>
<!--l. 3098--><p class="noindent" >The  speed  of  solution  is  roughly
proportionate<span class="footnote-mark"><a 
href="SolvingMicroDSOPs29.html#fn28x0"><sup class="textsuperscript">28</sup></a></span><a 
 id="x1-34001f28"></a> 
to the number of points used in approximating the distribution of shocks. At least 3 gridpoints
should probably be used as an initial minimum, and my experience is that increasing the
number of gridpoints beyond 7 generally yields only very small changes in the solution. The
program <span 
class="ectt-1200">multiperiodCon_infhor.m </span>begins with three gridpoints, and then solves for
successively ﬁner <img 
src="SolvingMicroDSOPs692x.svg" alt="𝜃   " class="math";align="absmiddle"><span 
class="ectt-1200">Vec</span>.
<!--l. 3112--><p class="indent" >  <a 
 id="StructuralEstimation"></a>
  <h3 class="sectionHead"><span class="titlemark">9  </span> <a 
 id="x1-350009"></a>Structural Estimation</h3>
<!--l. 3115--><p class="noindent" >This section describes how to use the methods developed above to structurally
estimate a life-cycle consumption model, following closely the work of
<a 
href="#XcagettiWprofiles">Cagetti</a> (<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs30.html#fn29x0"><sup class="textsuperscript">29</sup></a></span><a 
 id="x1-35001f29"></a> 
The key idea of structural estimation is to look for the parameter values (for the time
preference rate, relative risk aversion, or other parameters) which lead to the best possible
match between simulated and empirical moments. (The code for the structural estimation is in
the self-contained subfolder <span 
class="ectt-1200">StructuralEstimation </span>in the Matlab and <span 
class="ecti-1200">Mathematica</span>
directories.)
<!--l. 3127--><p class="indent" >  <a 
 id="LifeCycleModel"></a>
                                                                                     
                                                                                     
  <h4 class="subsectionHead"><span class="titlemark">9.1  </span> <a 
 id="x1-360009.1"></a>Life Cycle Model</h4>
<!--l. 3130--><p class="noindent" >The decision problem for the household at age <img 
src="SolvingMicroDSOPs693x.svg" alt="t  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td><a 
 id="x1-36001r96"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs694x.svg" alt="     {           [  T                         ]}
                   ∑     s− t(  s    ˆ  )
max    u(ct) + 𝔼t       ℶ     Π i=t+1βiℵi  u(cs)
                  s=t+1
" class="math-display" ></center></td><td class="equation-label">(96)</td></tr></table>
<!--l. 3--><p class="nopar" >
subject to the constraints <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs695x.svg" alt="   as  =  ms  − cs
ms+1   =  Ras +  Ys+1

 Ys+1  =  ppps+1𝜃s+1
 ppps+1  =  Γ s+1pppsΨs+1
" class="math-display" ></center>
</div>where
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs696x.svg" alt=" ℵs  : probability alive (not dead) until age s given alive at age s − 1
 ˆβs  : time -varying discount factor between age s − 1 and s
Ψ    : mean  -one shock  to permanent  income
  s
 ℶ   : time -invariant discount factor
" class="math-display" ></center>
</div> and all the other variables are deﬁned as in section <a 
href="#x1-20002">2<!--tex4ht:ref: sec:basicproblem --></a>.
<!--l. 3156--><p class="indent" >  Households start life at age <img 
src="SolvingMicroDSOPs697x.svg" alt="s = 25  " class="math";align="absmiddle"> and live with probability 1 until retirement (<img 
src="SolvingMicroDSOPs698x.svg" alt="s = 65  " class="math";align="absmiddle">).
Thereafter the survival probability shrinks every year and agents are dead by <img 
src="SolvingMicroDSOPs699x.svg" alt="s = 91  " class="math";align="absmiddle"> as
assumed by Cagetti. Note that in addition to a typical time-invariant discount factor <img 
src="SolvingMicroDSOPs700x.svg" alt="ℶ  " class="math";align="absmiddle">,
there is a time-varying discount factor <img 
src="SolvingMicroDSOPs701x.svg" alt=" ˆ
βs  " class="math";align="absmiddle"> in (<a 
href="#x1-36001r96">96<!--tex4ht:ref: eq:lifecyclemax --></a>) which captures the eﬀect of time-varying
demographic variables (e.g. changes in family size).
<!--l. 3163--><p class="indent" >  Transitory and permanent shocks are distributed as follows: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs702x.svg" alt="           {
             0      with probability ℘ &#x003E; 0
   Ξs  =                                                                   (97)
             𝜃s∕℘   with probability (1 − ℘), where log𝜃s ∽ 𝒩 (− σ2𝜃∕2, σ2𝜃)
                 2     2
log ψs  ∽   𝒩 (− σψ∕2, σψ)                                                  (98)
" class="math-display" ></center>
</div>where <img 
src="SolvingMicroDSOPs703x.svg" alt="℘  " class="math";align="absmiddle"> is the probability of unemployment (and unemployment shocks are turned oﬀ after
retirement).
<!--l. 3174--><p class="indent" >  The parameter values for the shocks are taken from Carroll (<a 
href="#Xcarroll:brookings">1992</a>), <img 
src="SolvingMicroDSOPs704x.svg" alt="℘ = 0.5∕100  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs705x.svg" alt="σ 𝜃 = 0.1  " class="math";align="absmiddle">, and
<img 
src="SolvingMicroDSOPs706x.svg" alt="σ  =  0.1
  ψ  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs31.html#fn30x0"><sup class="textsuperscript">30</sup></a></span><a 
 id="x1-36005f30"></a>  The income
growth proﬁle <img 
src="SolvingMicroDSOPs710x.svg" alt="Γ s  " class="math";align="absmiddle"> is from Carroll (<a 
href="#XcarrollBSLCPIH">1997</a>) and the values of <img 
src="SolvingMicroDSOPs711x.svg" alt="ℵs  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs712x.svg" alt="ˆβs  " class="math";align="absmiddle"> are obtained from Cagetti (<a 
href="#XcagettiWprofiles">2003</a>)
(Figure <a 
href="#x1-3600722">22<!--tex4ht:ref: fig:TimeVaryingParam --></a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs32.html#fn31x0"><sup class="textsuperscript">31</sup></a></span><a 
 id="x1-36006f31"></a> 
The interest rate is assumed to equal <img 
src="SolvingMicroDSOPs713x.svg" alt="1.03  " class="math";align="absmiddle">. The model parameters are included in Table
                                                                                     
                                                                                     
<a 
href="#x1-360081">1<!--tex4ht:ref: table:StrEstParams --></a>.
<!--l. 3177--><p class="indent" >  <a 
 id="PlotTimeVaryingParam"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3600722"></a>
                                                                                     
                                                                                     
<!--l. 3179--><p class="noindent" > <img 
src="./Figures/PlotTimeVaryingParam.png" alt="pict"  
 width="602.25pt" >
<br /> <div class="caption" 
><span class="id">Figure 22: </span><span  
class="content">Time Varying Parameters</span></div><!--tex4ht:label?: x1-3600722 -->
                                                                                     
                                                                                     
  </div>
  <div class="table">
                                                                                     
                                                                                     
<!--l. 3184--><p class="indent" >  <a 
 id="x1-360081"></a><hr class="float"><div class="float" 
>
                                                                                     
                                                                                     
 <div class="caption" 
><span class="id">Table 1: </span><span  
class="content">Parameter Values</span></div><!--tex4ht:label?: x1-360081 -->
<div class="center" 
>
<!--l. 3186--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs714x.svg" alt="-----------------------------------
   σ𝜃      0.1     Carroll (1992)
  σ ψ      0.1     Carroll (1992)

   ℘      0.005    Carroll (1992)
   Γ s   ﬁgure 22  Carroll (1997)
 ˆβs,ℵs   ﬁgure 22  Cagetti (2003 )
   R       1.03    Cagetti (2003 )
-----------------------------------
" ></div></div>
                                                                                     
                                                                                     
  </div><hr class="endfloat" />
  </div>
<!--l. 3200--><p class="indent" >  The parameters <img 
src="SolvingMicroDSOPs715x.svg" alt="ℶ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs716x.svg" alt="ρ  " class="math";align="absmiddle"> are structurally estimated following the procedure described
below.
  <h4 class="subsectionHead"><span class="titlemark">9.2  </span> <a 
 id="x1-370009.2"></a>Estimation</h4>
<!--l. 3204--><p class="noindent" >When economists say that they are performing “structural estimation” of a model like this, they
mean that they have devised a formal procedure for searching for values for the parameters <img 
src="SolvingMicroDSOPs717x.svg" alt="ℶ  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs718x.svg" alt="ρ  " class="math";align="absmiddle"> at which some measure of the model’s outcome (like “median wealth by age”) is as
close as possible to an empirical measure of the same thing. Here, we choose to match the
median of the wealth to permanent income ratio across 7 age groups, from age <img 
src="SolvingMicroDSOPs719x.svg" alt="26 − 30  " class="math";align="absmiddle"> up to
<img 
src="SolvingMicroDSOPs720x.svg" alt="56 − 60  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs33.html#fn32x0"><sup class="textsuperscript">32</sup></a></span><a 
 id="x1-37001f32"></a> 
The choice of matching the medians rather the means is motivated by the fact that the wealth
distribution is much more concentrated at the top than the model is capable of
explaining using a single set of parameter values. This means that in practice one
must pick some portion of the population who one wants to match well; since the
model has little hope of capturing the behavior of Bill Gates, but might conceivably
match the behavior of Homer Simpson, we choose to match medians rather than
means.
<!--l. 3226--><p class="indent" >  As explained in section <a 
href="#x1-30003">3<!--tex4ht:ref: sec:normalization --></a>, it is convenient to work with the normalized version the model
which can be written as:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs721x.svg" alt="                 {                                             }
                                ˆ                1−ρ
vt(mt)   =   macxt   u(ct) + ℶ ℵt+1βt+1𝔼t [(ψt+1Γ t+1)  vt+1(mt+1 )]
        s.t.

    at   =   mt(− ct      )
                 ---R-----
 mt+1    =   at  ψ   Γ      +𝜃t+1
               ◟--t+1◝◜-t+1-◞
                   ≡ℛt+1
" class="math-display" ></center>
</div> with the ﬁrst order condition: <div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs722x.svg" alt="u ′(c ) =   ℶ ℵ   ˆβ   R 𝔼 [u′(ψ   Γ   c   (a ℛ    +  𝜃  ))].         (99)
    t         t+1 t+1   t     t+1  t+1 t+1  t  t+1    t+1
" class="math-display" ><a 
 id="x1-37003r99"></a></center>
</div>
<!--l. 3243--><p class="indent" >  The ﬁrst step is to solve for the consumption functions at each age using the routines
included in the <span 
class="ectt-1200">setup_ConsFn.m </span>ﬁle. We need to discretize the shock distribution and solve
for the policy functions by backward induction using equation (<a 
href="#x1-37003r99">99<!--tex4ht:ref: eq:FOCLifeCycle --></a>) following the
procedure in sections <a 
href="#x1-50005">5<!--tex4ht:ref: sec:NextToLast --></a> and <a 
href="#x1-210006">6<!--tex4ht:ref: sec:recursion --></a> (<span 
class="ectt-1200">ConstructcFuncLife</span>). The latter routine is slightly
complicated by the fact that we are considering a life-cycle model and therefore
the growth rate of permanent income, the probability of death, the time-varying
discount factor and the distribution of shocks will be diﬀerent across the years. We
thus must ensure that at each backward iteration the right parameter values are
used.
<!--l. 3256--><p class="indent" >  Once we have the age varying consumption functions, we can proceed to generate the
simulated data and compute the simulated medians using the routines deﬁned in the
<span 
class="ectt-1200">setup_Sim.m </span>ﬁle. We ﬁrst have to draw the shocks for each agent and period. This
involves discretizing the shock distribution for as many points as the number of
agents we want to simulate (<span 
class="ectt-1200">ConstructShockDistribution</span>). We then randomly
permute this shock vector as many times as we need to simulate the model for,
thus obtaining a time varying shock for each agent (<span 
class="ectt-1200">ConstructSimShocks</span>). This is
much more time eﬃcient than drawing at each time from the shock distribution a
shock for each agent, and also ensures a stable distribution of shocks across the
simulation periods even for a small number of agents. (Similarly, in order to speed up the
process, at each backward iteration we compute the consumption function and other
variables as a vector at once.) Then, following Cagetti  (<a 
href="#XcagettiWprofiles">2003</a>), we initialize the
wealth-to-income ratio of agents at age <img 
src="SolvingMicroDSOPs723x.svg" alt="25  " class="math";align="absmiddle"> by randomly assigning the equal probability
                                                                                     
                                                                                     
values to <img 
src="SolvingMicroDSOPs724x.svg" alt="0.17  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs725x.svg" alt="0.50  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs726x.svg" alt="0.83  " class="math";align="absmiddle"> and run the simulation (<span 
class="ectt-1200">Simulate</span>). In particular we
consider a population of agents at age 25 and follow their consumption and wealth
accumulation dynamics as they reach the age of <img 
src="SolvingMicroDSOPs727x.svg" alt="60  " class="math";align="absmiddle">, using the appropriate age-speciﬁc
consumption functions and the age-varying parameters. The simulated medians
are obtained by taking the medians of the wealth to income ratio of the <img 
src="SolvingMicroDSOPs728x.svg" alt="7  " class="math";align="absmiddle"> age
groups.
<!--l. 3281--><p class="indent" >  Given these simulated medians, we can estimate the model by calculating empirical medians
and measure the model’s success by calculating the diﬀerence between the empirical median
and the actual median. Speciﬁcally, deﬁning <img 
src="SolvingMicroDSOPs729x.svg" alt="ξ  " class="math";align="absmiddle"> as the set of parameters to be estimated
(in the current case <img 
src="SolvingMicroDSOPs730x.svg" alt="ξ = { ρ,ℶ} " class="math";align="absmiddle">), we could search for the parameter values which
solve
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs731x.svg" alt="    ∑ 7
min     |ςτ − sτ(ξ)|                              (100)
  ξ  τ=1
" class="math-display" ><a 
 id="x1-37004r100"></a></center>
</div> where <img 
src="SolvingMicroDSOPs732x.svg" alt="ςτ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs733x.svg" alt="sτ  " class="math";align="absmiddle"> are respectively the empirical and simulated medians of the wealth to
permanent income ratio for age group <img 
src="SolvingMicroDSOPs734x.svg" alt="τ  " class="math";align="absmiddle">.
<!--l. 3295--><p class="indent" >  A drawback of proceeding in this way is that it treats the empirically estimated medians as
though they reﬂected perfect measurements of the truth. Imagine, however, that
one of the age groups happened to have (in the consumer survey) four times as
many data observations as another age group; then we would expect the median to
be more precisely estimated for the age group with more observations; yet (<a 
href="#x1-37004r100">100<!--tex4ht:ref: eq:naivePowell --></a>)
assigns equal importance to a deviation between the model and the data for all age
groups.
<!--l. 3304--><p class="indent" >  We can get around this problem (and a variety of others) by instead minimizing a slightly
more complex object:
  <table 
class="equation"><tr><td><a 
 id="x1-37005r101"></a>
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs735x.svg" alt="    ∑N
min     ωi|ςτi − sτ(ξ)|
 ξ   i
" class="math-display" ></center></td><td class="equation-label">(101)</td></tr></table>
<!--l. 3--><p class="nopar" >
where <img 
src="SolvingMicroDSOPs736x.svg" alt="ωi  " class="math";align="absmiddle">  is the weight of household <img 
src="SolvingMicroDSOPs737x.svg" alt="i  " class="math";align="absmiddle"> in the entire
population,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs34.html#fn33x0"><sup class="textsuperscript">33</sup></a></span><a 
 id="x1-37006f33"></a> 
and <img 
src="SolvingMicroDSOPs738x.svg" alt="ςiτ  " class="math";align="absmiddle"> is the empirical wealth-to-permanent-income ratio of household <img 
src="SolvingMicroDSOPs739x.svg" alt="i  " class="math";align="absmiddle"> whose head
belongs to age group <img 
src="SolvingMicroDSOPs740x.svg" alt="τ  " class="math";align="absmiddle">. <img 
src="SolvingMicroDSOPs741x.svg" alt="ω
  i  " class="math";align="absmiddle"> is needed because unequal weight is assigned to each observation
in the Survey of Consumer Finances (SCF). The absolute value is used since the formula is
based on the fact that the median is the value that minimizes the sum of the absolute
deviations from itself.
<!--l. 3327--><p class="indent" >  The actual data are taken from several waves of the SCF and the medians and means for
each age category are plotted in ﬁgure <a 
href="#x1-3700723">23<!--tex4ht:ref: fig:MeanMedianSCF --></a>. More details on the SCF data are included in
appendix <a 
href="#x1-39000A">A<!--tex4ht:ref: app:SCFdata --></a>. <a 
 id="PlotMeanMedianSCFcollegeGrads"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3700723"></a>
                                                                                     
                                                                                     
<!--l. 3331--><p class="noindent" > <img 
src="./Figures/PlotMeanMedianSCFcollegeGrads.png" alt="pict"  
 width="301.125pt" >
<br /> <div class="caption" 
><span class="id">Figure 23: </span><span  
class="content">Wealth to Permanent Income Ratios from SCF (means (dashed) and medians
(solid))</span></div><!--tex4ht:label?: x1-3700723 -->
                                                                                     
                                                                                     
  </div>
<!--l. 3336--><p class="indent" >  The key function to perform structural estimation is deﬁned in the <span 
class="ectt-1200">setup_Estimation.m</span>
ﬁle as follows:
<div class="eqnarray">
  <center class="math-display" >
<img 
src="SolvingMicroDSOPs742x.svg" alt="GapEmpiricalSimulatedMedians     [ρ,ℶ ]:=
   [ ConstructcFuncLife    [ρ,ℶ ];

     Simulate;
     ∑N
         ωi |ςτi − sτ(ξ)|
       i

  ];
" class="math-display" ></center>
</div> For a given pair of the parameters to be estimated, the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
routine therefore:
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-37010x1">solves for the consumption functions by calling <span 
class="ectt-1200">ConstructcFuncLife</span>
      </li>
      <li 
  class="enumerate" id="x1-37012x2">simulates the data and computes the simulated medians by calling <span 
class="ectt-1200">Simulate</span>
      </li>
      <li 
  class="enumerate" id="x1-37014x3">returns the value of equation (<a 
href="#x1-37005r101">101<!--tex4ht:ref: eq:StructEstim --></a>)</li></ol>
<!--l. 3354--><p class="indent" >  We delegate the task of ﬁnding the coeﬃcients that minimize the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
function to the <span 
class="ecti-1200">Mathematica</span>  built-in numerical minimizer <span 
class="ectt-1200">FindMinimum</span>. This task can be
quite time demanding and rather problematic if the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians</span>
function has very ﬂat regions or sharp features. It is thus wise to verify the accuracy of the
solution, for example by experimenting with a variety of alternative starting values for the
parameter search.
<!--l. 3363--><p class="indent" >  Finally the standard errors are computed by bootstrap using the routines in the <span 
class="ectt-1200">setup_Bootstrap.m</span>
ﬁle.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs35.html#fn34x0"><sup class="textsuperscript">34</sup></a></span><a 
 id="x1-37015f34"></a> 
This involves:
                                                                                     
                                                                                     
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x1-37017x1">drawing new shocks for the simulation
      </li>
      <li 
  class="enumerate" id="x1-37019x2">drawing a random sample (with replacement) of actual data from the SCF
      </li>
      <li 
  class="enumerate" id="x1-37021x3">obtaining new estimates for <img 
src="SolvingMicroDSOPs743x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs744x.svg" alt="ℶ  " class="math";align="absmiddle"></li></ol>
<!--l. 3372--><p class="noindent" >We repeat the above procedure several times (<span 
class="ectt-1200">Bootstrap</span>) and take the standard deviation for
each of the estimated parameters across the various bootstrap iterations.
<!--l. 3374--><p class="indent" >  The ﬁle <span 
class="ectt-1200">StructEstimation.m </span>produces our <img 
src="SolvingMicroDSOPs745x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs746x.svg" alt="ℶ  " class="math";align="absmiddle"> estimates with standard errors using 10,000 simulated
agents.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs36.html#fn35x0"><sup class="textsuperscript">35</sup></a></span><a 
 id="x1-37022f35"></a>  Results are
reported in Table <a 
href="#x1-370242">2<!--tex4ht:ref: tab:EstResults --></a>.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs37.html#fn36x0"><sup class="textsuperscript">36</sup></a></span><a 
 id="x1-37023f36"></a> 
Figure <a 
href="#x1-3702524">24<!--tex4ht:ref: fig:PlotContourMedianStrEst --></a> shows the contour plot of the <span 
class="ectt-1200">GapEmpiricalSimulatedMedians </span>function and
the parameter estimates. The contour plot shows equally spaced isoquants of the
<span 
class="ectt-1200">GapEmpiricalSimulatedMedians </span>function, i.e. the pairs of <img 
src="SolvingMicroDSOPs749x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs750x.svg" alt="ℶ  " class="math";align="absmiddle"> which lead to the same
deviations between simulated and empirical medians (equivalent values of equation
(<a 
href="#x1-37005r101">101<!--tex4ht:ref: eq:StructEstim --></a>)). We can thus interestingly see that there is a large rather ﬂat region, or more
formally speaking there exists a broad set of parameter pairs which leads to similar
simulated wealth to income ratios. Intuitively, the ﬂatter and larger is this region,
the harder it is for the structural estimation procedure to precisely identify the
parameters.
<div class="table">
                                                                                     
                                                                                     
<!--l. 1--><p class="indent" >  <a 
 id="x1-370242"></a><hr class="float"><div class="float" 
>
                                                                                     
                                                                                     
 <div class="caption" 
><span class="id">Table 2: </span><span  
class="content">Estimation Results</span></div><!--tex4ht:label?: x1-370242 -->
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs751x.svg" alt="-----------------
---ρ-------ℶ-----
  4.68    1.00
 (0.13)  (0.00)
-----------------
" ></div>
                                                                                     
                                                                                     
  </div><hr class="endfloat" />
  </div>
<!--l. 3413--><p class="indent" >  <a 
 id="PlotContourMedianStrEst"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-3702524"></a>
                                                                                     
                                                                                     
<!--l. 3415--><p class="noindent" > <img 
src="./Figures/PlotContourMedianStrEst.png" alt="pict"  
 width="301.125pt" >
<br /> <div class="caption" 
><span class="id">Figure 24: </span><span  
class="content">Contour Plot (larger values are shown lighter) with <img 
src="SolvingMicroDSOPs752x.svg" alt="{ρ,ℶ } " class="math";align="absmiddle"> Estimates (red
dot).</span></div><!--tex4ht:label?: x1-3702524 -->
                                                                                     
                                                                                     
  </div>
  <h3 class="sectionHead"><span class="titlemark">10  </span> <a 
 id="x1-3800010"></a>Conclusion</h3>
<!--l. 3422--><p class="noindent" >There are many alternative choices that can be made for solving microeconomic dynamic
stochastic optimization problems. The set of techniques, and associated programs, described in
these notes represents an approach that I have found to be powerful, ﬂexible, and eﬃcient, but
other problems may require other techniques. For a much broader treatment of many of the
issues considered here, see Judd (<a 
href="#Xjudd:book">1998</a>).
                                                                                     
                                                                                     
  <div  
class="centerline">                                             <span 
class="ecrm-2074">Appendices</span>                            </div>
  <h3 class="sectionHead"><span class="titlemark">A  </span> <a 
 id="x1-39000A"></a>Further Details on SCF Data</h3>
<!--l. 3438--><p class="noindent" >Data used in the estimation is constructed using the SCF 1992, 1995, 1998,
2001 and 2004 waves. The deﬁnition of wealth is net worth including housing
wealth, but excluding pensions and social securities. The data set contains
only households whose heads are aged 26-60 and excludes singles, following
Cagetti (<a 
href="#XcagettiWprofiles">2003</a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs38.html#fn37x0"><sup class="textsuperscript">37</sup></a></span><a 
 id="x1-39001f37"></a> 
Furthermore, the data set contains only households whose heads are college graduates. The
total sample size is 4,774.
<!--l. 3440--><p class="indent" >  In the waves between 1995 and 2004 of the SCF, levels of <span 
class="ecti-1200">normal </span>income are reported. The
question in the questionnaire is &#x0022;About what would your income have been if it had been a
normal year?&#x0022; We consider the level of normal income as corresponding to the model’s
theoretical object <img 
src="SolvingMicroDSOPs753x.svg" alt="P  " class="math";align="absmiddle">, permanent noncapital income. Levels of normal income are not
reported in the 1992 wave. Instead, in this wave there is a variable which reports whether
the level of income is normal or not. Regarding the 1992 wave, only observations
which report that the level of income is normal are used, and the levels of income of
remaining observations in the 1992 wave are interpreted as the levels of permanent
income.
<!--l. 3452--><p class="indent" >  Normal income levels in the SCF are before-tax ﬁgures. These before-tax permanent income
ﬁgures must be rescaled so that the median of the rescaled permanent income of each age
group matches the median of each age group’s income which is assumed in the simulation.
This rescaled permanent income is interpreted as after-tax permanent income. This rescaling
is crucial since in the estimation empirical proﬁles are matched with simulated ones which are
generated using after-tax permanent income (remember the income process assumed in the
main text). Wealth / permanent income ratio is computed by dividing the level of
wealth by the level of (after-tax) permanent income, and this ratio is used for the
estimation.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs39.html#fn38x0"><sup class="textsuperscript">38</sup></a></span><a 
 id="x1-39002f38"></a> 
                                                                                     
                                                                                     
  <h3 class="likesectionHead"><a 
 id="x1-40000A"></a>References</h3>
<!--l. 5--><p class="noindent" >
  <div class="thebibliography">
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XAttanasioBanksMeghirWeber"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">A</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">o</span><span 
class="small-caps">,</span> <span 
class="small-caps">O</span><span 
class="small-caps">.</span><span 
class="small-caps">P</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span> <span 
class="small-caps">J</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-"> <span 
class="small-caps">B</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">k</span><span 
class="small-caps">s</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-"> <span 
class="small-caps">M</span><span 
class="small-caps">e</span><span 
class="small-caps">g</span><span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">r</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">G</span><span 
class="small-caps">.</span></span><span 
class="eccc1200-"> <span 
class="small-caps">W</span><span 
class="small-caps">e</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> </span>(1999): “Humps and
  Bumps in Lifetime Consumption,” <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 17(1),
  22–35.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcagettiWprofiles"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">g</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">t</span><span 
class="small-caps">i</span><span 
class="small-caps">,</span>  <span 
class="small-caps">M</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">c</span><span 
class="small-caps">o</span>  </span>(2003):  “Wealth  Accumulation  Over  the  Life  Cycle  and
  Precautionary Savings,” <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 21(3), 339–353.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll:brookings"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-"> <span 
class="small-caps">D</span><span 
class="small-caps">.</span> </span>(1992): “The Buﬀer-Stock Theory of Saving: Some
  Macroeconomic Evidence,” <span 
class="ecti-1200">Brookings Papers on Economic Activity</span>, 1992(2), 61–156,
  <a 
href="http://econ.jhu.edu/people/ccarroll/BufferStockBPEA.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/BufferStockBPEA.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcarrollBSLCPIH"></a><span class="bibsp">   </span></span>__________<span 
class="eccc1200-">               </span>(1997):                “Buﬀer                Stock                Saving
  and the Life Cycle/Permanent Income Hypothesis,” <span 
class="ecti-1200">Quarterly Journal of Economics</span>,
  CXII(1), 1–56, <a 
href="http://econ.jhu.edu/people/ccarroll/BSLCPIH.zip" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/BSLCPIH.zip</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XcarrollEGM"></a><span class="bibsp">   </span></span>__________<span 
class="eccc1200-">       </span>(2006):       “The       Method       of       Endogenous       Gridpoints
  for Solving Dynamic Stochastic Optimization Problems,”  <span 
class="ecti-1200">Economics Letters</span>, 91(3),
  312–320, <a 
href="http://econ.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/EndogenousGridpoints.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XBufferStockTheory"></a><span class="bibsp">   </span></span>__________<span 
class="eccc1200-">                                  </span>(2020):                                     “Theoretical
  Foundations of Buﬀer Stock Saving,” <span 
class="ecti-1200">Forthcoming, </span>Quantitative Economics, Available
  at <a 
href="http://econ.jhu.edu/people/ccarroll/papers/BufferStockTheory" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/papers/BufferStockTheory</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XMathFacts"></a><span class="bibsp">   </span></span>__________<span 
class="eccc1200-">  </span>(Current):  “Math  Facts  Useful  for  Graduate  Macroeconomics,”  Online
  Lecture Notes.
  </p>
                                                                                     
                                                                                     
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll&kimball:concavity"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span>               <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-"> <span 
class="small-caps">D</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span>               <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>               <span 
class="small-caps">M</span><span 
class="small-caps">i</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">s</span></span><span 
class="eccc1200-"> <span 
class="small-caps">S</span><span 
class="small-caps">.</span></span>
  <span 
class="eccc1200-"><span 
class="small-caps">K</span><span 
class="small-caps">i</span><span 
class="small-caps">m</span><span 
class="small-caps">b</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span> </span>(1996): “On the Concavity of the Consumption Function,” <span 
class="ecti-1200">Econometrica</span>,
  64(4), 981–992, <a 
href="http://econ.jhu.edu/people/ccarroll/concavity.pdf" class="url" ><span 
class="ectt-1200">http://econ.jhu.edu/people/ccarroll/concavity.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xcarroll&samwick:nature"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">C</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">,</span> <span 
class="small-caps">C</span><span 
class="small-caps">h</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-"> <span 
class="small-caps">D</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">A</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">w</span></span><span 
class="eccc1200-"> <span 
class="small-caps">A</span><span 
class="small-caps">.</span> <span 
class="small-caps">S</span><span 
class="small-caps">a</span><span 
class="small-caps">m</span><span 
class="small-caps">w</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span> </span>(1997): “The Nature
  of Precautionary Wealth,” <span 
class="ecti-1200">Journal of Monetary Economics</span>, 40(1), 41–71.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XdeatonLiqConstr"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">D</span><span 
class="small-caps">e</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">A</span><span 
class="small-caps">n</span><span 
class="small-caps">g</span><span 
class="small-caps">u</span><span 
class="small-caps">s</span></span><span 
class="eccc1200-"> <span 
class="small-caps">S</span><span 
class="small-caps">.</span> </span>(1991): “Saving and Liquidity Constraints,” <span 
class="ecti-1200">Econometrica</span>, 59,
  1221–1248, <a 
href="http://www.jstor.org/stable/2938366" class="url" ><span 
class="ectt-1200">http://www.jstor.org/stable/2938366</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XdenHaanMarcet:parameterized"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">d</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span>                      <span 
class="small-caps">H</span><span 
class="small-caps">a</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span>                      <span 
class="small-caps">W</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span></span><span 
class="eccc1200-"> <span 
class="small-caps">J</span><span 
class="small-caps">,</span>                      <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span></span>
  <span 
class="eccc1200-"><span 
class="small-caps">A</span><span 
class="small-caps">l</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span> <span 
class="small-caps">M</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">c</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span> </span>(1990): “Solving the Stochastic Growth Model by Parameterizing
  Expectations,” <span 
class="ecti-1200">Journal of Business and Economic Statistics</span>, 8(1), 31–34, Available at
  <a 
href="http://ideas.repec.org/a/bes/jnlbes/v8y1990i1p31-34.html" class="url" ><span 
class="ectt-1200">http://ideas.repec.org/a/bes/jnlbes/v8y1990i1p31-34.html</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XgpLifecycle"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">G</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">s</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">-</span><span 
class="small-caps">O</span><span 
class="small-caps">l</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">,</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> <span 
class="small-caps">J</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">k</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> </span>(2002): “Consumption
  Over the Life Cycle,” <span 
class="ecti-1200">Econometrica</span>, 70(1), 47–89.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="XhorowitzBootstrap"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">H</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span><span 
class="small-caps">o</span><span 
class="small-caps">w</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">z</span><span 
class="small-caps">,</span> <span 
class="small-caps">J</span><span 
class="small-caps">o</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-"> <span 
class="small-caps">L</span><span 
class="small-caps">.</span> </span>(2001): “The Bootstrap,” in <span 
class="ecti-1200">Handbook of Econometrics</span>, ed. by
  James J. Heckman, and Edward Leamer, vol. 5. Elsevier/North Holland.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xjudd:book"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">J</span><span 
class="small-caps">u</span><span 
class="small-caps">d</span><span 
class="small-caps">d</span><span 
class="small-caps">,</span> <span 
class="small-caps">K</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">n</span><span 
class="small-caps">e</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span></span><span 
class="eccc1200-"> <span 
class="small-caps">L</span><span 
class="small-caps">.</span> </span>(1998): <span 
class="ecti-1200">Numerical Methods in Economics</span>. The MIT Press,
  Cambridge, Massachusetts.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xkopecky2010finite"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">K</span><span 
class="small-caps">o</span><span 
class="small-caps">p</span><span 
class="small-caps">e</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">y</span><span 
class="small-caps">,</span>   <span 
class="small-caps">K</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span></span><span 
class="eccc1200-"> <span 
class="small-caps">A</span><span 
class="small-caps">.</span><span 
class="small-caps">,</span>   <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>   <span 
class="small-caps">R</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">d</span></span><span 
class="eccc1200-"> <span 
class="small-caps">M</span><span 
class="small-caps">.</span><span 
class="small-caps">H</span><span 
class="small-caps">.</span>   <span 
class="small-caps">S</span><span 
class="small-caps">u</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span>  </span>(2010):   “Finite   State
  Markov-Chain Approximations To Highly Persistent Processes,” <span 
class="ecti-1200">Review of Economic</span>
  <span 
class="ecti-1200">Dynamics</span>, 13(3), 701–714, <a 
href="http://www.karenkopecky.net/RouwenhorstPaper.pdf" class="url" ><span 
class="ectt-1200">http://www.karenkopecky.net/RouwenhorstPaper.pdf</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xmerton:restat"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">M</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">R</span><span 
class="small-caps">o</span><span 
class="small-caps">b</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">t</span></span><span 
class="eccc1200-"> <span 
class="small-caps">C</span><span 
class="small-caps">.</span> </span>(1969): “Lifetime Portfolio Selection under Uncertainty: The
  Continuous Time Case,” <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 247–257.
                                                                                     
                                                                                     
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xpalumbo:medical"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">u</span><span 
class="small-caps">m</span><span 
class="small-caps">b</span><span 
class="small-caps">o</span><span 
class="small-caps">,</span> <span 
class="small-caps">M</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-"> <span 
class="small-caps">G</span> </span>(1999): “Uncertain Medical Expenses and Precautionary
  Saving Near the End of the Life Cycle,” <span 
class="ecti-1200">Review of Economic Studies</span>, 66(2), 395–421,
  Available at <a 
href="http://ideas.repec.org/a/bla/restud/v66y1999i2p395-421.html" class="url" ><span 
class="ectt-1200">http://ideas.repec.org/a/bla/restud/v66y1999i2p395-421.html</span></a>.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xsamuelson:portfolio"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">S</span><span 
class="small-caps">a</span><span 
class="small-caps">m</span><span 
class="small-caps">u</span><span 
class="small-caps">e</span><span 
class="small-caps">l</span><span 
class="small-caps">s</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">,</span> <span 
class="small-caps">P</span><span 
class="small-caps">a</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span></span><span 
class="eccc1200-"> <span 
class="small-caps">A</span><span 
class="small-caps">.</span> </span>(1969): “Lifetime Portfolio Selection by Dynamic Stochastic
  Programming,” <span 
class="ecti-1200">Review of Economics and Statistics</span>, 51, 239–46.
  </p>
  <p class="bibitem" ><span class="biblabel">
<a 
 id="Xvalencia:2006"></a><span class="bibsp">   </span></span><span 
class="eccc1200-"><span 
class="small-caps">V</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">i</span><span 
class="small-caps">a</span><span 
class="small-caps">,</span> <span 
class="small-caps">F</span><span 
class="small-caps">a</span><span 
class="small-caps">b</span><span 
class="small-caps">i</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span> </span>(2006): “Banks’ Financial Structure and Business Cycles,” Ph.D.
  thesis, Johns Hopkins University.
</p>
  </div>
   
</body> 
</html>
                                                                                     


